//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3 2013-02-21 18:05:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class aegiscriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COMMENT", "DIGIT", "ESC_SEQ", "EXPONENT", "FLOAT", "HEX_DIGIT", "IDENT", "INTEGER", "LETTER", "MULTILINE_COMMENT", "OCTAL_ESC", "UNICODE_ESC", "WS", "'('", "')'", "'*'", "'+'", "','", "'-'", "'/'", "'/='", "':'", "';'", "'<'", "'<='", "'='", "'>'", "'>='", "'Integer'", "'and'", "'begin'", "'constant'", "'else'", "'elsif'", "'end'", "'if'", "'mod'", "'not'", "'or'", "'var'", "'while'"
	};
	public const int EOF=-1;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int COMMENT=4;
	public const int DIGIT=5;
	public const int ESC_SEQ=6;
	public const int EXPONENT=7;
	public const int FLOAT=8;
	public const int HEX_DIGIT=9;
	public const int IDENT=10;
	public const int INTEGER=11;
	public const int LETTER=12;
	public const int MULTILINE_COMMENT=13;
	public const int OCTAL_ESC=14;
	public const int UNICODE_ESC=15;
	public const int WS=16;

	public aegiscriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public aegiscriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return aegiscriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:16:1: public program : 'begin' ( statement )* 'end' ';' ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal1 = default(IToken);
		IToken string_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement2 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal1_tree = default(object);
		object string_literal3_tree = default(object);
		object char_literal4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(16, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:17:2: ( 'begin' ( statement )* 'end' ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:18:3: 'begin' ( statement )* 'end' ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(18, 3);
			string_literal1=(IToken)Match(input,34,Follow._34_in_program44); 
			string_literal1_tree = (object)adaptor.Create(string_literal1);
			adaptor.AddChild(root_0, string_literal1_tree);
			DebugLocation(19, 3);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:19:3: ( statement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==IDENT||LA1_1==39||LA1_1==44))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:19:3: statement
					{
					DebugLocation(19, 3);
					PushFollow(Follow._statement_in_program48);
					statement2=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement2.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(20, 3);
			string_literal3=(IToken)Match(input,38,Follow._38_in_program53); 
			string_literal3_tree = (object)adaptor.Create(string_literal3);
			adaptor.AddChild(root_0, string_literal3_tree);
			DebugLocation(20, 9);
			char_literal4=(IToken)Match(input,26,Follow._26_in_program55); 
			char_literal4_tree = (object)adaptor.Create(char_literal4);
			adaptor.AddChild(root_0, char_literal4_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(21, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:23:1: constant : 'constant' type IDENT '=' expression ';' ;
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 2);
		TraceIn("constant", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal5 = default(IToken);
		IToken IDENT7 = default(IToken);
		IToken char_literal8 = default(IToken);
		IToken char_literal10 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression9 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal5_tree = default(object);
		object IDENT7_tree = default(object);
		object char_literal8_tree = default(object);
		object char_literal10_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(23, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:24:2: ( 'constant' type IDENT '=' expression ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:24:4: 'constant' type IDENT '=' expression ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(24, 4);
			string_literal5=(IToken)Match(input,35,Follow._35_in_constant66); 
			string_literal5_tree = (object)adaptor.Create(string_literal5);
			adaptor.AddChild(root_0, string_literal5_tree);
			DebugLocation(24, 15);
			PushFollow(Follow._type_in_constant68);
			type6=type();
			PopFollow();

			adaptor.AddChild(root_0, type6.Tree);
			DebugLocation(24, 20);
			IDENT7=(IToken)Match(input,IDENT,Follow._IDENT_in_constant70); 
			IDENT7_tree = (object)adaptor.Create(IDENT7);
			adaptor.AddChild(root_0, IDENT7_tree);
			DebugLocation(24, 26);
			char_literal8=(IToken)Match(input,29,Follow._29_in_constant72); 
			char_literal8_tree = (object)adaptor.Create(char_literal8);
			adaptor.AddChild(root_0, char_literal8_tree);
			DebugLocation(24, 30);
			PushFollow(Follow._expression_in_constant74);
			expression9=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression9.Tree);
			DebugLocation(24, 41);
			char_literal10=(IToken)Match(input,26,Follow._26_in_constant76); 
			char_literal10_tree = (object)adaptor.Create(char_literal10);
			adaptor.AddChild(root_0, char_literal10_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 2);
			LeaveRule("constant", 2);
			LeaveRule_constant();
		}
		DebugLocation(25, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();
	// $ANTLR start "variable"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:27:1: variable : 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<object, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal11 = default(IToken);
		IToken IDENT12 = default(IToken);
		IToken char_literal13 = default(IToken);
		IToken IDENT14 = default(IToken);
		IToken char_literal15 = default(IToken);
		IToken char_literal17 = default(IToken);
		IToken char_literal19 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression18 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal11_tree = default(object);
		object IDENT12_tree = default(object);
		object char_literal13_tree = default(object);
		object IDENT14_tree = default(object);
		object char_literal15_tree = default(object);
		object char_literal17_tree = default(object);
		object char_literal19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(27, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:2: ( 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:4: 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(28, 4);
			string_literal11=(IToken)Match(input,43,Follow._43_in_variable87); 
			string_literal11_tree = (object)adaptor.Create(string_literal11);
			adaptor.AddChild(root_0, string_literal11_tree);
			DebugLocation(28, 10);
			IDENT12=(IToken)Match(input,IDENT,Follow._IDENT_in_variable89); 
			IDENT12_tree = (object)adaptor.Create(IDENT12);
			adaptor.AddChild(root_0, IDENT12_tree);
			DebugLocation(28, 16);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:16: ( ',' IDENT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==21))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:17: ',' IDENT
					{
					DebugLocation(28, 17);
					char_literal13=(IToken)Match(input,21,Follow._21_in_variable92); 
					char_literal13_tree = (object)adaptor.Create(char_literal13);
					adaptor.AddChild(root_0, char_literal13_tree);
					DebugLocation(28, 21);
					IDENT14=(IToken)Match(input,IDENT,Follow._IDENT_in_variable94); 
					IDENT14_tree = (object)adaptor.Create(IDENT14);
					adaptor.AddChild(root_0, IDENT14_tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(28, 29);
			char_literal15=(IToken)Match(input,25,Follow._25_in_variable98); 
			char_literal15_tree = (object)adaptor.Create(char_literal15);
			adaptor.AddChild(root_0, char_literal15_tree);
			DebugLocation(28, 33);
			PushFollow(Follow._type_in_variable100);
			type16=type();
			PopFollow();

			adaptor.AddChild(root_0, type16.Tree);
			DebugLocation(28, 38);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:38: ( '=' expression )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==29))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:28:39: '=' expression
				{
				DebugLocation(28, 39);
				char_literal17=(IToken)Match(input,29,Follow._29_in_variable103); 
				char_literal17_tree = (object)adaptor.Create(char_literal17);
				adaptor.AddChild(root_0, char_literal17_tree);
				DebugLocation(28, 43);
				PushFollow(Follow._expression_in_variable105);
				expression18=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(28, 56);
			char_literal19=(IToken)Match(input,26,Follow._26_in_variable109); 
			char_literal19_tree = (object)adaptor.Create(char_literal19);
			adaptor.AddChild(root_0, char_literal19_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(29, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:31:1: type : 'Integer' ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal20 = default(IToken);

		object string_literal20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(31, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:32:2: ( 'Integer' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:32:4: 'Integer'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(32, 4);
			string_literal20=(IToken)Match(input,32,Follow._32_in_type121); 
			string_literal20_tree = (object)adaptor.Create(string_literal20);
			adaptor.AddChild(root_0, string_literal20_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(33, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:35:1: ifStatement : 'if' expression ':' ( statement )* ( 'elsif' expression ':' ( statement )* )* ( 'else' ':' ( statement )* )? 'end' 'if' ';' ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<object, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 5);
		TraceIn("ifStatement", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal21 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken string_literal25 = default(IToken);
		IToken char_literal27 = default(IToken);
		IToken string_literal29 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken string_literal32 = default(IToken);
		IToken string_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression26 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement31 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal21_tree = default(object);
		object char_literal23_tree = default(object);
		object string_literal25_tree = default(object);
		object char_literal27_tree = default(object);
		object string_literal29_tree = default(object);
		object char_literal30_tree = default(object);
		object string_literal32_tree = default(object);
		object string_literal33_tree = default(object);
		object char_literal34_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(35, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:36:2: ( 'if' expression ':' ( statement )* ( 'elsif' expression ':' ( statement )* )* ( 'else' ':' ( statement )* )? 'end' 'if' ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:36:4: 'if' expression ':' ( statement )* ( 'elsif' expression ':' ( statement )* )* ( 'else' ':' ( statement )* )? 'end' 'if' ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(36, 4);
			string_literal21=(IToken)Match(input,39,Follow._39_in_ifStatement133); 
			string_literal21_tree = (object)adaptor.Create(string_literal21);
			adaptor.AddChild(root_0, string_literal21_tree);
			DebugLocation(36, 9);
			PushFollow(Follow._expression_in_ifStatement135);
			expression22=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression22.Tree);
			DebugLocation(36, 20);
			char_literal23=(IToken)Match(input,25,Follow._25_in_ifStatement137); 
			char_literal23_tree = (object)adaptor.Create(char_literal23);
			adaptor.AddChild(root_0, char_literal23_tree);
			DebugLocation(37, 3);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:37:3: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==IDENT||LA4_1==39||LA4_1==44))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:37:3: statement
					{
					DebugLocation(37, 3);
					PushFollow(Follow._statement_in_ifStatement141);
					statement24=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement24.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(38, 5);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:38:5: ( 'elsif' expression ':' ( statement )* )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==37))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:38:6: 'elsif' expression ':' ( statement )*
					{
					DebugLocation(38, 6);
					string_literal25=(IToken)Match(input,37,Follow._37_in_ifStatement149); 
					string_literal25_tree = (object)adaptor.Create(string_literal25);
					adaptor.AddChild(root_0, string_literal25_tree);
					DebugLocation(38, 14);
					PushFollow(Follow._expression_in_ifStatement151);
					expression26=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression26.Tree);
					DebugLocation(38, 25);
					char_literal27=(IToken)Match(input,25,Follow._25_in_ifStatement153); 
					char_literal27_tree = (object)adaptor.Create(char_literal27);
					adaptor.AddChild(root_0, char_literal27_tree);
					DebugLocation(39, 7);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:39:7: ( statement )*
					try { DebugEnterSubRule(5);
					while (true)
					{
						int alt5=2;
						try { DebugEnterDecision(5, false);
						int LA5_1 = input.LA(1);

						if ((LA5_1==IDENT||LA5_1==39||LA5_1==44))
						{
							alt5 = 1;
						}


						} finally { DebugExitDecision(5); }
						switch ( alt5 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:39:7: statement
							{
							DebugLocation(39, 7);
							PushFollow(Follow._statement_in_ifStatement161);
							statement28=statement();
							PopFollow();

							adaptor.AddChild(root_0, statement28.Tree);

							}
							break;

						default:
							goto loop5;
						}
					}

					loop5:
						;

					} finally { DebugExitSubRule(5); }


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(40, 5);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:40:5: ( 'else' ':' ( statement )* )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==36))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:40:6: 'else' ':' ( statement )*
				{
				DebugLocation(40, 6);
				string_literal29=(IToken)Match(input,36,Follow._36_in_ifStatement172); 
				string_literal29_tree = (object)adaptor.Create(string_literal29);
				adaptor.AddChild(root_0, string_literal29_tree);
				DebugLocation(40, 13);
				char_literal30=(IToken)Match(input,25,Follow._25_in_ifStatement174); 
				char_literal30_tree = (object)adaptor.Create(char_literal30);
				adaptor.AddChild(root_0, char_literal30_tree);
				DebugLocation(41, 7);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:41:7: ( statement )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if ((LA7_1==IDENT||LA7_1==39||LA7_1==44))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:41:7: statement
						{
						DebugLocation(41, 7);
						PushFollow(Follow._statement_in_ifStatement182);
						statement31=statement();
						PopFollow();

						adaptor.AddChild(root_0, statement31.Tree);

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(42, 7);
			string_literal32=(IToken)Match(input,38,Follow._38_in_ifStatement194); 
			string_literal32_tree = (object)adaptor.Create(string_literal32);
			adaptor.AddChild(root_0, string_literal32_tree);
			DebugLocation(42, 13);
			string_literal33=(IToken)Match(input,39,Follow._39_in_ifStatement196); 
			string_literal33_tree = (object)adaptor.Create(string_literal33);
			adaptor.AddChild(root_0, string_literal33_tree);
			DebugLocation(42, 18);
			char_literal34=(IToken)Match(input,26,Follow._26_in_ifStatement198); 
			char_literal34_tree = (object)adaptor.Create(char_literal34);
			adaptor.AddChild(root_0, char_literal34_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 5);
			LeaveRule("ifStatement", 5);
			LeaveRule_ifStatement();
		}
		DebugLocation(43, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:45:1: whileStatement : 'while' expression ':' ( statement )* 'end' 'while' ';' ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<object, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 6);
		TraceIn("whileStatement", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal35 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken string_literal39 = default(IToken);
		IToken string_literal40 = default(IToken);
		IToken char_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement38 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal35_tree = default(object);
		object char_literal37_tree = default(object);
		object string_literal39_tree = default(object);
		object string_literal40_tree = default(object);
		object char_literal41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(45, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:46:2: ( 'while' expression ':' ( statement )* 'end' 'while' ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:46:4: 'while' expression ':' ( statement )* 'end' 'while' ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(46, 4);
			string_literal35=(IToken)Match(input,44,Follow._44_in_whileStatement209); 
			string_literal35_tree = (object)adaptor.Create(string_literal35);
			adaptor.AddChild(root_0, string_literal35_tree);
			DebugLocation(46, 12);
			PushFollow(Follow._expression_in_whileStatement211);
			expression36=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression36.Tree);
			DebugLocation(46, 23);
			char_literal37=(IToken)Match(input,25,Follow._25_in_whileStatement213); 
			char_literal37_tree = (object)adaptor.Create(char_literal37);
			adaptor.AddChild(root_0, char_literal37_tree);
			DebugLocation(47, 3);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:47:3: ( statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==IDENT||LA9_1==39||LA9_1==44))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:47:3: statement
					{
					DebugLocation(47, 3);
					PushFollow(Follow._statement_in_whileStatement217);
					statement38=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement38.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(48, 3);
			string_literal39=(IToken)Match(input,38,Follow._38_in_whileStatement222); 
			string_literal39_tree = (object)adaptor.Create(string_literal39);
			adaptor.AddChild(root_0, string_literal39_tree);
			DebugLocation(48, 9);
			string_literal40=(IToken)Match(input,44,Follow._44_in_whileStatement224); 
			string_literal40_tree = (object)adaptor.Create(string_literal40);
			adaptor.AddChild(root_0, string_literal40_tree);
			DebugLocation(48, 17);
			char_literal41=(IToken)Match(input,26,Follow._26_in_whileStatement226); 
			char_literal41_tree = (object)adaptor.Create(char_literal41);
			adaptor.AddChild(root_0, char_literal41_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 6);
			LeaveRule("whileStatement", 6);
			LeaveRule_whileStatement();
		}
		DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:51:1: statement : ( assignmentStatement | whileStatement | ifStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 7);
		TraceIn("statement", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assignmentStatement42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> whileStatement43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifStatement44 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(51, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:52:2: ( assignmentStatement | whileStatement | ifStatement )
			int alt10=3;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt10 = 1;
				}
				break;
			case 44:
				{
				alt10 = 2;
				}
				break;
			case 39:
				{
				alt10 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:52:4: assignmentStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 4);
				PushFollow(Follow._assignmentStatement_in_statement237);
				assignmentStatement42=assignmentStatement();
				PopFollow();

				adaptor.AddChild(root_0, assignmentStatement42.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:53:4: whileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 4);
				PushFollow(Follow._whileStatement_in_statement242);
				whileStatement43=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement43.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:54:4: ifStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(54, 4);
				PushFollow(Follow._ifStatement_in_statement247);
				ifStatement44=ifStatement();
				PopFollow();

				adaptor.AddChild(root_0, ifStatement44.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 7);
			LeaveRule("statement", 7);
			LeaveRule_statement();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_assignmentStatement();
	partial void LeaveRule_assignmentStatement();
	// $ANTLR start "assignmentStatement"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:57:1: assignmentStatement : IDENT '=' expression ';' ;
	[GrammarRule("assignmentStatement")]
	private AstParserRuleReturnScope<object, IToken> assignmentStatement()
	{
		EnterRule_assignmentStatement();
		EnterRule("assignmentStatement", 8);
		TraceIn("assignmentStatement", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENT45 = default(IToken);
		IToken char_literal46 = default(IToken);
		IToken char_literal48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression47 = default(AstParserRuleReturnScope<object, IToken>);

		object IDENT45_tree = default(object);
		object char_literal46_tree = default(object);
		object char_literal48_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentStatement");
		DebugLocation(57, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:58:2: ( IDENT '=' expression ';' )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:58:4: IDENT '=' expression ';'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(58, 4);
			IDENT45=(IToken)Match(input,IDENT,Follow._IDENT_in_assignmentStatement258); 
			IDENT45_tree = (object)adaptor.Create(IDENT45);
			adaptor.AddChild(root_0, IDENT45_tree);
			DebugLocation(58, 10);
			char_literal46=(IToken)Match(input,29,Follow._29_in_assignmentStatement260); 
			char_literal46_tree = (object)adaptor.Create(char_literal46);
			adaptor.AddChild(root_0, char_literal46_tree);
			DebugLocation(58, 14);
			PushFollow(Follow._expression_in_assignmentStatement262);
			expression47=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression47.Tree);
			DebugLocation(58, 25);
			char_literal48=(IToken)Match(input,26,Follow._26_in_assignmentStatement264); 
			char_literal48_tree = (object)adaptor.Create(char_literal48);
			adaptor.AddChild(root_0, char_literal48_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentStatement", 8);
			LeaveRule("assignmentStatement", 8);
			LeaveRule_assignmentStatement();
		}
		DebugLocation(59, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentStatement"); }
		return retval;

	}
	// $ANTLR end "assignmentStatement"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:61:1: term : ( IDENT | '(' expression ')' | INTEGER );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 9);
		TraceIn("term", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENT49 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken INTEGER53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression51 = default(AstParserRuleReturnScope<object, IToken>);

		object IDENT49_tree = default(object);
		object char_literal50_tree = default(object);
		object char_literal52_tree = default(object);
		object INTEGER53_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(61, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:62:2: ( IDENT | '(' expression ')' | INTEGER )
			int alt11=3;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt11 = 1;
				}
				break;
			case 17:
				{
				alt11 = 2;
				}
				break;
			case INTEGER:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:62:4: IDENT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(62, 4);
				IDENT49=(IToken)Match(input,IDENT,Follow._IDENT_in_term277); 
				IDENT49_tree = (object)adaptor.Create(IDENT49);
				adaptor.AddChild(root_0, IDENT49_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:63:4: '(' expression ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(63, 4);
				char_literal50=(IToken)Match(input,17,Follow._17_in_term282); 
				char_literal50_tree = (object)adaptor.Create(char_literal50);
				adaptor.AddChild(root_0, char_literal50_tree);
				DebugLocation(63, 8);
				PushFollow(Follow._expression_in_term284);
				expression51=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression51.Tree);
				DebugLocation(63, 19);
				char_literal52=(IToken)Match(input,18,Follow._18_in_term286); 
				char_literal52_tree = (object)adaptor.Create(char_literal52);
				adaptor.AddChild(root_0, char_literal52_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:64:4: INTEGER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(64, 4);
				INTEGER53=(IToken)Match(input,INTEGER,Follow._INTEGER_in_term291); 
				INTEGER53_tree = (object)adaptor.Create(INTEGER53);
				adaptor.AddChild(root_0, INTEGER53_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 9);
			LeaveRule("term", 9);
			LeaveRule_term();
		}
		DebugLocation(65, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_negation();
	partial void LeaveRule_negation();
	// $ANTLR start "negation"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:67:1: negation : ( 'not' )* term ;
	[GrammarRule("negation")]
	private AstParserRuleReturnScope<object, IToken> negation()
	{
		EnterRule_negation();
		EnterRule("negation", 10);
		TraceIn("negation", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal54 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term55 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal54_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "negation");
		DebugLocation(67, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:68:2: ( ( 'not' )* term )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:68:4: ( 'not' )* term
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(68, 4);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:68:4: ( 'not' )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==41))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:68:4: 'not'
					{
					DebugLocation(68, 4);
					string_literal54=(IToken)Match(input,41,Follow._41_in_negation303); 
					string_literal54_tree = (object)adaptor.Create(string_literal54);
					adaptor.AddChild(root_0, string_literal54_tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(68, 11);
			PushFollow(Follow._term_in_negation306);
			term55=term();
			PopFollow();

			adaptor.AddChild(root_0, term55.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negation", 10);
			LeaveRule("negation", 10);
			LeaveRule_negation();
		}
		DebugLocation(69, 1);
		} finally { DebugExitRule(GrammarFileName, "negation"); }
		return retval;

	}
	// $ANTLR end "negation"

	partial void EnterRule_unary();
	partial void LeaveRule_unary();
	// $ANTLR start "unary"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:71:1: unary : ( '+' | '-' )* negation ;
	[GrammarRule("unary")]
	private AstParserRuleReturnScope<object, IToken> unary()
	{
		EnterRule_unary();
		EnterRule("unary", 11);
		TraceIn("unary", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> negation57 = default(AstParserRuleReturnScope<object, IToken>);

		object set56_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unary");
		DebugLocation(71, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:72:2: ( ( '+' | '-' )* negation )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:72:4: ( '+' | '-' )* negation
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(72, 4);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:72:4: ( '+' | '-' )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==20||LA13_1==22))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:
					{
					DebugLocation(72, 4);

					set56=(IToken)input.LT(1);
					if (input.LA(1)==20||input.LA(1)==22)
					{
						input.Consume();
						adaptor.AddChild(root_0, (object)adaptor.Create(set56));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(72, 17);
			PushFollow(Follow._negation_in_unary327);
			negation57=negation();
			PopFollow();

			adaptor.AddChild(root_0, negation57.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary", 11);
			LeaveRule("unary", 11);
			LeaveRule_unary();
		}
		DebugLocation(73, 1);
		} finally { DebugExitRule(GrammarFileName, "unary"); }
		return retval;

	}
	// $ANTLR end "unary"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:75:1: mult : unary ( ( '*' | '/' | 'mod' ) unary )* ;
	[GrammarRule("mult")]
	private AstParserRuleReturnScope<object, IToken> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 12);
		TraceIn("mult", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set59 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unary58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unary60 = default(AstParserRuleReturnScope<object, IToken>);

		object set59_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(75, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:76:2: ( unary ( ( '*' | '/' | 'mod' ) unary )* )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:76:4: unary ( ( '*' | '/' | 'mod' ) unary )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(76, 4);
			PushFollow(Follow._unary_in_mult338);
			unary58=unary();
			PopFollow();

			adaptor.AddChild(root_0, unary58.Tree);
			DebugLocation(76, 10);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:76:10: ( ( '*' | '/' | 'mod' ) unary )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==19||LA14_1==23||LA14_1==40))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:76:11: ( '*' | '/' | 'mod' ) unary
					{
					DebugLocation(76, 11);

					set59=(IToken)input.LT(1);
					if (input.LA(1)==19||input.LA(1)==23||input.LA(1)==40)
					{
						input.Consume();
						adaptor.AddChild(root_0, (object)adaptor.Create(set59));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(76, 31);
					PushFollow(Follow._unary_in_mult353);
					unary60=unary();
					PopFollow();

					adaptor.AddChild(root_0, unary60.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult", 12);
			LeaveRule("mult", 12);
			LeaveRule_mult();
		}
		DebugLocation(77, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_add();
	partial void LeaveRule_add();
	// $ANTLR start "add"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:79:1: add : mult ( ( '+' | '-' ) mult )* ;
	[GrammarRule("add")]
	private AstParserRuleReturnScope<object, IToken> add()
	{
		EnterRule_add();
		EnterRule("add", 13);
		TraceIn("add", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set62 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mult61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mult63 = default(AstParserRuleReturnScope<object, IToken>);

		object set62_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(79, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:80:2: ( mult ( ( '+' | '-' ) mult )* )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:80:4: mult ( ( '+' | '-' ) mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(80, 4);
			PushFollow(Follow._mult_in_add367);
			mult61=mult();
			PopFollow();

			adaptor.AddChild(root_0, mult61.Tree);
			DebugLocation(80, 9);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:80:9: ( ( '+' | '-' ) mult )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==20||LA15_1==22))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:80:10: ( '+' | '-' ) mult
					{
					DebugLocation(80, 10);

					set62=(IToken)input.LT(1);
					if (input.LA(1)==20||input.LA(1)==22)
					{
						input.Consume();
						adaptor.AddChild(root_0, (object)adaptor.Create(set62));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(80, 22);
					PushFollow(Follow._mult_in_add378);
					mult63=mult();
					PopFollow();

					adaptor.AddChild(root_0, mult63.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add", 13);
			LeaveRule("add", 13);
			LeaveRule_add();
		}
		DebugLocation(81, 1);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();
	// $ANTLR start "relation"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:83:1: relation : add ( ( '=' | '/=' | '<' | '<=' | '>=' | '>' ) add )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<object, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 14);
		TraceIn("relation", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set65 = default(IToken);
		AstParserRuleReturnScope<object, IToken> add64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> add66 = default(AstParserRuleReturnScope<object, IToken>);

		object set65_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(83, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:84:2: ( add ( ( '=' | '/=' | '<' | '<=' | '>=' | '>' ) add )* )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:84:4: add ( ( '=' | '/=' | '<' | '<=' | '>=' | '>' ) add )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(84, 4);
			PushFollow(Follow._add_in_relation391);
			add64=add();
			PopFollow();

			adaptor.AddChild(root_0, add64.Tree);
			DebugLocation(84, 8);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:84:8: ( ( '=' | '/=' | '<' | '<=' | '>=' | '>' ) add )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==24||(LA16_1>=27 && LA16_1<=31)))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:84:9: ( '=' | '/=' | '<' | '<=' | '>=' | '>' ) add
					{
					DebugLocation(84, 9);

					set65=(IToken)input.LT(1);
					if (input.LA(1)==24||(input.LA(1)>=27 && input.LA(1)<=31))
					{
						input.Consume();
						adaptor.AddChild(root_0, (object)adaptor.Create(set65));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(84, 48);
					PushFollow(Follow._add_in_relation418);
					add66=add();
					PopFollow();

					adaptor.AddChild(root_0, add66.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 14);
			LeaveRule("relation", 14);
			LeaveRule_relation();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:87:1: expression : relation ( ( 'and' | 'or' ) relation )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 15);
		TraceIn("expression", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set68 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relation67 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relation69 = default(AstParserRuleReturnScope<object, IToken>);

		object set68_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(87, 1);
		try
		{
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:88:2: ( relation ( ( 'and' | 'or' ) relation )* )
			DebugEnterAlt(1);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:88:4: relation ( ( 'and' | 'or' ) relation )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(88, 4);
			PushFollow(Follow._relation_in_expression432);
			relation67=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation67.Tree);
			DebugLocation(88, 13);
			// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:88:13: ( ( 'and' | 'or' ) relation )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==33||LA17_1==42))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\David\\Subversion\\AEGIScript\\Lang\\aegiscript.g3:88:14: ( 'and' | 'or' ) relation
					{
					DebugLocation(88, 14);

					set68=(IToken)input.LT(1);
					if (input.LA(1)==33||input.LA(1)==42)
					{
						input.Consume();
						adaptor.AddChild(root_0, (object)adaptor.Create(set68));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(88, 29);
					PushFollow(Follow._relation_in_expression443);
					relation69=relation();
					PopFollow();

					adaptor.AddChild(root_0, relation69.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 15);
			LeaveRule("expression", 15);
			LeaveRule_expression();
		}
		DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _34_in_program44 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _statement_in_program48 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _38_in_program53 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_program55 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _35_in_constant66 = new BitSet(new ulong[]{0x0000000100000000UL});
		public static readonly BitSet _type_in_constant68 = new BitSet(new ulong[]{0x0000000000000400UL});
		public static readonly BitSet _IDENT_in_constant70 = new BitSet(new ulong[]{0x0000000020000000UL});
		public static readonly BitSet _29_in_constant72 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_constant74 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_constant76 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _43_in_variable87 = new BitSet(new ulong[]{0x0000000000000400UL});
		public static readonly BitSet _IDENT_in_variable89 = new BitSet(new ulong[]{0x0000000002200000UL});
		public static readonly BitSet _21_in_variable92 = new BitSet(new ulong[]{0x0000000000000400UL});
		public static readonly BitSet _IDENT_in_variable94 = new BitSet(new ulong[]{0x0000000002200000UL});
		public static readonly BitSet _25_in_variable98 = new BitSet(new ulong[]{0x0000000100000000UL});
		public static readonly BitSet _type_in_variable100 = new BitSet(new ulong[]{0x0000000024000000UL});
		public static readonly BitSet _29_in_variable103 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_variable105 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_variable109 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _32_in_type121 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _39_in_ifStatement133 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_ifStatement135 = new BitSet(new ulong[]{0x0000000002000000UL});
		public static readonly BitSet _25_in_ifStatement137 = new BitSet(new ulong[]{0x000010F000000400UL});
		public static readonly BitSet _statement_in_ifStatement141 = new BitSet(new ulong[]{0x000010F000000400UL});
		public static readonly BitSet _37_in_ifStatement149 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_ifStatement151 = new BitSet(new ulong[]{0x0000000002000000UL});
		public static readonly BitSet _25_in_ifStatement153 = new BitSet(new ulong[]{0x000010F000000400UL});
		public static readonly BitSet _statement_in_ifStatement161 = new BitSet(new ulong[]{0x000010F000000400UL});
		public static readonly BitSet _36_in_ifStatement172 = new BitSet(new ulong[]{0x0000000002000000UL});
		public static readonly BitSet _25_in_ifStatement174 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _statement_in_ifStatement182 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _38_in_ifStatement194 = new BitSet(new ulong[]{0x0000008000000000UL});
		public static readonly BitSet _39_in_ifStatement196 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_ifStatement198 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _44_in_whileStatement209 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_whileStatement211 = new BitSet(new ulong[]{0x0000000002000000UL});
		public static readonly BitSet _25_in_whileStatement213 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _statement_in_whileStatement217 = new BitSet(new ulong[]{0x000010C000000400UL});
		public static readonly BitSet _38_in_whileStatement222 = new BitSet(new ulong[]{0x0000100000000000UL});
		public static readonly BitSet _44_in_whileStatement224 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_whileStatement226 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _assignmentStatement_in_statement237 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _whileStatement_in_statement242 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ifStatement_in_statement247 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _IDENT_in_assignmentStatement258 = new BitSet(new ulong[]{0x0000000020000000UL});
		public static readonly BitSet _29_in_assignmentStatement260 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_assignmentStatement262 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _26_in_assignmentStatement264 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _IDENT_in_term277 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _17_in_term282 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _expression_in_term284 = new BitSet(new ulong[]{0x0000000000040000UL});
		public static readonly BitSet _18_in_term286 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _INTEGER_in_term291 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _41_in_negation303 = new BitSet(new ulong[]{0x0000020000020C00UL});
		public static readonly BitSet _term_in_negation306 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _negation_in_unary327 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _unary_in_mult338 = new BitSet(new ulong[]{0x0000010000880002UL});
		public static readonly BitSet _set_in_mult341 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _unary_in_mult353 = new BitSet(new ulong[]{0x0000010000880002UL});
		public static readonly BitSet _mult_in_add367 = new BitSet(new ulong[]{0x0000000000500002UL});
		public static readonly BitSet _set_in_add370 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _mult_in_add378 = new BitSet(new ulong[]{0x0000000000500002UL});
		public static readonly BitSet _add_in_relation391 = new BitSet(new ulong[]{0x00000000F9000002UL});
		public static readonly BitSet _set_in_relation394 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _add_in_relation418 = new BitSet(new ulong[]{0x00000000F9000002UL});
		public static readonly BitSet _relation_in_expression432 = new BitSet(new ulong[]{0x0000040200000002UL});
		public static readonly BitSet _set_in_expression435 = new BitSet(new ulong[]{0x0000020000520C00UL});
		public static readonly BitSet _relation_in_expression443 = new BitSet(new ulong[]{0x0000040200000002UL});
	}
	#endregion Follow sets
}
