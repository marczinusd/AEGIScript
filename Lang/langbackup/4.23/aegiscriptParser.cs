//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 D:\\Eclipse\\aegiscript_live\\aegiscript.g 2013-04-20 17:27:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019





using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace 
    AEGIScript.Lang

{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class aegiscriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARRAY", "BOOL", "COMMENT", "DIGIT", "ESC_SEQ", "EXPONENT", "FLOAT", "FUNC", "HEX_DIGIT", "IDENT", "INTEGER", "LETTER", "MULTILINE_COMMENT", "OCTAL_ESC", "STRING", "UNICODE_ESC", "WS", "'!='", "'&&'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'/'", "':'", "';'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'Integer'", "'['", "']'", "'begin'", "'constant'", "'else'", "'elsif'", "'end'", "'endif'", "'if'", "'mod'", "'not'", "'var'", "'while'", "'||'"
	};
	public const int EOF=-1;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int ARRAY=4;
	public const int BOOL=5;
	public const int COMMENT=6;
	public const int DIGIT=7;
	public const int ESC_SEQ=8;
	public const int EXPONENT=9;
	public const int FLOAT=10;
	public const int FUNC=11;
	public const int HEX_DIGIT=12;
	public const int IDENT=13;
	public const int INTEGER=14;
	public const int LETTER=15;
	public const int MULTILINE_COMMENT=16;
	public const int OCTAL_ESC=17;
	public const int STRING=18;
	public const int UNICODE_ESC=19;
	public const int WS=20;

	public aegiscriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public aegiscriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return aegiscriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Eclipse\\aegiscript_live\\aegiscript.g"; } }

	int HIDDEN = Hidden;

	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:31:1: public program : 'begin' ^ ( statement )* 'end' ';' EOF ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal1 = default(IToken);
		IToken string_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);
		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal1_tree = default(CommonTree);
		CommonTree string_literal3_tree = default(CommonTree);
		CommonTree char_literal4_tree = default(CommonTree);
		CommonTree EOF5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(31, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:32:2: ( 'begin' ^ ( statement )* 'end' ';' EOF )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:33:3: 'begin' ^ ( statement )* 'end' ';' EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(33, 10);
			string_literal1=(IToken)Match(input,41,Follow._41_in_program94); 
			string_literal1_tree = (CommonTree)adaptor.Create(string_literal1);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal1_tree, root_0);
			DebugLocation(34, 3);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: ( statement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==IDENT||LA1_1==47||LA1_1==51))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: statement
					{
					DebugLocation(34, 3);
					PushFollow(Follow._statement_in_program99);
					statement2=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement2.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(35, 3);
			string_literal3=(IToken)Match(input,45,Follow._45_in_program104); 
			string_literal3_tree = (CommonTree)adaptor.Create(string_literal3);
			adaptor.AddChild(root_0, string_literal3_tree);
			DebugLocation(35, 9);
			char_literal4=(IToken)Match(input,31,Follow._31_in_program106); 
			char_literal4_tree = (CommonTree)adaptor.Create(char_literal4);
			adaptor.AddChild(root_0, char_literal4_tree);
			DebugLocation(35, 13);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_program108); 
			EOF5_tree = (CommonTree)adaptor.Create(EOF5);
			adaptor.AddChild(root_0, EOF5_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:38:1: constant : 'constant' type IDENT '=' expression ';' ;
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<CommonTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 2);
		TraceIn("constant", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal6 = default(IToken);
		IToken IDENT8 = default(IToken);
		IToken char_literal9 = default(IToken);
		IToken char_literal11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression10 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal6_tree = default(CommonTree);
		CommonTree IDENT8_tree = default(CommonTree);
		CommonTree char_literal9_tree = default(CommonTree);
		CommonTree char_literal11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(38, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:2: ( 'constant' type IDENT '=' expression ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:4: 'constant' type IDENT '=' expression ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(39, 4);
			string_literal6=(IToken)Match(input,42,Follow._42_in_constant119); 
			string_literal6_tree = (CommonTree)adaptor.Create(string_literal6);
			adaptor.AddChild(root_0, string_literal6_tree);
			DebugLocation(39, 15);
			PushFollow(Follow._type_in_constant121);
			type7=type();
			PopFollow();

			adaptor.AddChild(root_0, type7.Tree);
			DebugLocation(39, 20);
			IDENT8=(IToken)Match(input,IDENT,Follow._IDENT_in_constant123); 
			IDENT8_tree = (CommonTree)adaptor.Create(IDENT8);
			adaptor.AddChild(root_0, IDENT8_tree);
			DebugLocation(39, 26);
			char_literal9=(IToken)Match(input,34,Follow._34_in_constant125); 
			char_literal9_tree = (CommonTree)adaptor.Create(char_literal9);
			adaptor.AddChild(root_0, char_literal9_tree);
			DebugLocation(39, 30);
			PushFollow(Follow._expression_in_constant127);
			expression10=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression10.Tree);
			DebugLocation(39, 41);
			char_literal11=(IToken)Match(input,31,Follow._31_in_constant129); 
			char_literal11_tree = (CommonTree)adaptor.Create(char_literal11);
			adaptor.AddChild(root_0, char_literal11_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 2);
			LeaveRule("constant", 2);
			LeaveRule_constant();
		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();
	// $ANTLR start "variable"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:42:1: variable : 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<CommonTree, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal12 = default(IToken);
		IToken IDENT13 = default(IToken);
		IToken char_literal14 = default(IToken);
		IToken IDENT15 = default(IToken);
		IToken char_literal16 = default(IToken);
		IToken char_literal18 = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal12_tree = default(CommonTree);
		CommonTree IDENT13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree IDENT15_tree = default(CommonTree);
		CommonTree char_literal16_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(42, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:2: ( 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:4: 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(43, 4);
			string_literal12=(IToken)Match(input,50,Follow._50_in_variable140); 
			string_literal12_tree = (CommonTree)adaptor.Create(string_literal12);
			adaptor.AddChild(root_0, string_literal12_tree);
			DebugLocation(43, 10);
			IDENT13=(IToken)Match(input,IDENT,Follow._IDENT_in_variable142); 
			IDENT13_tree = (CommonTree)adaptor.Create(IDENT13);
			adaptor.AddChild(root_0, IDENT13_tree);
			DebugLocation(43, 16);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:16: ( ',' IDENT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==27))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:17: ',' IDENT
					{
					DebugLocation(43, 17);
					char_literal14=(IToken)Match(input,27,Follow._27_in_variable145); 
					char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
					adaptor.AddChild(root_0, char_literal14_tree);
					DebugLocation(43, 21);
					IDENT15=(IToken)Match(input,IDENT,Follow._IDENT_in_variable147); 
					IDENT15_tree = (CommonTree)adaptor.Create(IDENT15);
					adaptor.AddChild(root_0, IDENT15_tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(43, 29);
			char_literal16=(IToken)Match(input,30,Follow._30_in_variable151); 
			char_literal16_tree = (CommonTree)adaptor.Create(char_literal16);
			adaptor.AddChild(root_0, char_literal16_tree);
			DebugLocation(43, 33);
			PushFollow(Follow._type_in_variable153);
			type17=type();
			PopFollow();

			adaptor.AddChild(root_0, type17.Tree);
			DebugLocation(43, 38);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:38: ( '=' expression )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==34))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:39: '=' expression
				{
				DebugLocation(43, 39);
				char_literal18=(IToken)Match(input,34,Follow._34_in_variable156); 
				char_literal18_tree = (CommonTree)adaptor.Create(char_literal18);
				adaptor.AddChild(root_0, char_literal18_tree);
				DebugLocation(43, 43);
				PushFollow(Follow._expression_in_variable158);
				expression19=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(43, 56);
			char_literal20=(IToken)Match(input,31,Follow._31_in_variable162); 
			char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
			adaptor.AddChild(root_0, char_literal20_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:46:1: type : 'Integer' ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<CommonTree, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal21 = default(IToken);

		CommonTree string_literal21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(46, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:2: ( 'Integer' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:4: 'Integer'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(47, 4);
			string_literal21=(IToken)Match(input,38,Follow._38_in_type174); 
			string_literal21_tree = (CommonTree)adaptor.Create(string_literal21);
			adaptor.AddChild(root_0, string_literal21_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:50:1: ifStatement : 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 5);
		TraceIn("ifStatement", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal22 = default(IToken);
		IToken char_literal24 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement25 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elsif26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> else_g27 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endif28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal22_tree = default(CommonTree);
		CommonTree char_literal24_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(50, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:2: ( 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:4: 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(51, 8);
			string_literal22=(IToken)Match(input,47,Follow._47_in_ifStatement186); 
			string_literal22_tree = (CommonTree)adaptor.Create(string_literal22);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal22_tree, root_0);
			DebugLocation(51, 10);
			PushFollow(Follow._expression_in_ifStatement189);
			expression23=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression23.Tree);
			DebugLocation(51, 21);
			char_literal24=(IToken)Match(input,30,Follow._30_in_ifStatement191); 
			char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
			adaptor.AddChild(root_0, char_literal24_tree);
			DebugLocation(51, 25);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==IDENT||LA4_1==47||LA4_1==51))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: statement
					{
					DebugLocation(51, 25);
					PushFollow(Follow._statement_in_ifStatement193);
					statement25=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement25.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(51, 36);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: ( elsif )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==44))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: elsif
					{
					DebugLocation(51, 36);
					PushFollow(Follow._elsif_in_ifStatement196);
					elsif26=elsif();
					PopFollow();

					adaptor.AddChild(root_0, elsif26.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(51, 43);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: ( else_g )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==43))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: else_g
				{
				DebugLocation(51, 43);
				PushFollow(Follow._else_g_in_ifStatement199);
				else_g27=else_g();
				PopFollow();

				adaptor.AddChild(root_0, else_g27.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(51, 51);
			PushFollow(Follow._endif_in_ifStatement202);
			endif28=endif();
			PopFollow();

			adaptor.AddChild(root_0, endif28.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 5);
			LeaveRule("ifStatement", 5);
			LeaveRule_ifStatement();
		}
		DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_elsif();
	partial void LeaveRule_elsif();
	// $ANTLR start "elsif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:53:1: elsif : 'elsif' ^ expression ':' ( statement )+ ;
	[GrammarRule("elsif")]
	private AstParserRuleReturnScope<CommonTree, IToken> elsif()
	{
		EnterRule_elsif();
		EnterRule("elsif", 6);
		TraceIn("elsif", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression30 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement32 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal29_tree = default(CommonTree);
		CommonTree char_literal31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "elsif");
		DebugLocation(53, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:2: ( 'elsif' ^ expression ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:4: 'elsif' ^ expression ':' ( statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(54, 11);
			string_literal29=(IToken)Match(input,44,Follow._44_in_elsif212); 
			string_literal29_tree = (CommonTree)adaptor.Create(string_literal29);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal29_tree, root_0);
			DebugLocation(54, 13);
			PushFollow(Follow._expression_in_elsif215);
			expression30=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression30.Tree);
			DebugLocation(54, 24);
			char_literal31=(IToken)Match(input,30,Follow._30_in_elsif217); 
			char_literal31_tree = (CommonTree)adaptor.Create(char_literal31);
			adaptor.AddChild(root_0, char_literal31_tree);
			DebugLocation(54, 28);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: ( statement )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==IDENT||LA7_1==47||LA7_1==51))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: statement
					{
					DebugLocation(54, 28);
					PushFollow(Follow._statement_in_elsif219);
					statement32=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement32.Tree);

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elsif", 6);
			LeaveRule("elsif", 6);
			LeaveRule_elsif();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "elsif"); }
		return retval;

	}
	// $ANTLR end "elsif"

	partial void EnterRule_else_g();
	partial void LeaveRule_else_g();
	// $ANTLR start "else_g"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:56:1: else_g : ( 'else' ^ ':' ( statement )+ ) ;
	[GrammarRule("else_g")]
	private AstParserRuleReturnScope<CommonTree, IToken> else_g()
	{
		EnterRule_else_g();
		EnterRule("else_g", 7);
		TraceIn("else_g", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal33_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "else_g");
		DebugLocation(56, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:2: ( ( 'else' ^ ':' ( statement )+ ) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(57, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:5: 'else' ^ ':' ( statement )+
			{
			DebugLocation(57, 11);
			string_literal33=(IToken)Match(input,43,Follow._43_in_else_g231); 
			string_literal33_tree = (CommonTree)adaptor.Create(string_literal33);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal33_tree, root_0);
			DebugLocation(57, 13);
			char_literal34=(IToken)Match(input,30,Follow._30_in_else_g234); 
			char_literal34_tree = (CommonTree)adaptor.Create(char_literal34);
			adaptor.AddChild(root_0, char_literal34_tree);
			DebugLocation(57, 17);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: ( statement )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==IDENT||LA8_1==47||LA8_1==51))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: statement
					{
					DebugLocation(57, 17);
					PushFollow(Follow._statement_in_else_g236);
					statement35=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement35.Tree);

					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("else_g", 7);
			LeaveRule("else_g", 7);
			LeaveRule_else_g();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "else_g"); }
		return retval;

	}
	// $ANTLR end "else_g"

	partial void EnterRule_endif();
	partial void LeaveRule_endif();
	// $ANTLR start "endif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:59:1: endif : 'endif' ';' ;
	[GrammarRule("endif")]
	private AstParserRuleReturnScope<CommonTree, IToken> endif()
	{
		EnterRule_endif();
		EnterRule("endif", 8);
		TraceIn("endif", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal36 = default(IToken);
		IToken char_literal37 = default(IToken);

		CommonTree string_literal36_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "endif");
		DebugLocation(59, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:2: ( 'endif' ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:4: 'endif' ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(60, 4);
			string_literal36=(IToken)Match(input,46,Follow._46_in_endif248); 
			string_literal36_tree = (CommonTree)adaptor.Create(string_literal36);
			adaptor.AddChild(root_0, string_literal36_tree);
			DebugLocation(60, 12);
			char_literal37=(IToken)Match(input,31,Follow._31_in_endif250); 
			char_literal37_tree = (CommonTree)adaptor.Create(char_literal37);
			adaptor.AddChild(root_0, char_literal37_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endif", 8);
			LeaveRule("endif", 8);
			LeaveRule_endif();
		}
		DebugLocation(61, 1);
		} finally { DebugExitRule(GrammarFileName, "endif"); }
		return retval;

	}
	// $ANTLR end "endif"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:63:1: whileStatement : 'while' ^ whileBody ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 9);
		TraceIn("whileStatement", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal38 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> whileBody39 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(63, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:2: ( 'while' ^ whileBody )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:4: 'while' ^ whileBody
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(64, 11);
			string_literal38=(IToken)Match(input,51,Follow._51_in_whileStatement262); 
			string_literal38_tree = (CommonTree)adaptor.Create(string_literal38);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal38_tree, root_0);
			DebugLocation(64, 13);
			PushFollow(Follow._whileBody_in_whileStatement265);
			whileBody39=whileBody();
			PopFollow();

			adaptor.AddChild(root_0, whileBody39.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 9);
			LeaveRule("whileStatement", 9);
			LeaveRule_whileStatement();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_whileBody();
	partial void LeaveRule_whileBody();
	// $ANTLR start "whileBody"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:69:1: whileBody : expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' ;
	[GrammarRule("whileBody")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileBody()
	{
		EnterRule_whileBody();
		EnterRule("whileBody", 10);
		TraceIn("whileBody", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal41 = default(IToken);
		IToken string_literal43 = default(IToken);
		IToken string_literal44 = default(IToken);
		IToken char_literal45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement42 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal41_tree = default(CommonTree);
		CommonTree string_literal43_tree = default(CommonTree);
		CommonTree string_literal44_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		RewriteRuleITokenStream stream_30=new RewriteRuleITokenStream(adaptor,"token 30");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileBody");
		DebugLocation(69, 77);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:2: ( expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:4: expression ':' ( statement )* 'end' 'while' ';'
			{
			DebugLocation(70, 4);
			PushFollow(Follow._expression_in_whileBody278);
			expression40=expression();
			PopFollow();

			stream_expression.Add(expression40.Tree);
			DebugLocation(70, 15);
			char_literal41=(IToken)Match(input,30,Follow._30_in_whileBody280);  
			stream_30.Add(char_literal41);

			DebugLocation(70, 19);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: ( statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==IDENT||LA9_1==47||LA9_1==51))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: statement
					{
					DebugLocation(70, 19);
					PushFollow(Follow._statement_in_whileBody282);
					statement42=statement();
					PopFollow();

					stream_statement.Add(statement42.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(70, 30);
			string_literal43=(IToken)Match(input,45,Follow._45_in_whileBody285);  
			stream_45.Add(string_literal43);

			DebugLocation(70, 36);
			string_literal44=(IToken)Match(input,51,Follow._51_in_whileBody287);  
			stream_51.Add(string_literal44);

			DebugLocation(70, 44);
			char_literal45=(IToken)Match(input,31,Follow._31_in_whileBody289);  
			stream_31.Add(char_literal45);



			{
			// AST REWRITE
			// elements: 45, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 70:48: -> expression ( statement )* 'end'
			{
				DebugLocation(70, 51);
				adaptor.AddChild(root_0, stream_expression.NextTree());
				DebugLocation(70, 62);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:62: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(70, 62);
					adaptor.AddChild(root_0, stream_statement.NextTree());

				}
				stream_statement.Reset();
				DebugLocation(70, 73);
				adaptor.AddChild(root_0, stream_45.NextNode());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileBody", 10);
			LeaveRule("whileBody", 10);
			LeaveRule_whileBody();
		}
		DebugLocation(70, 77);
		} finally { DebugExitRule(GrammarFileName, "whileBody"); }
		return retval;

	}
	// $ANTLR end "whileBody"

	partial void EnterRule_funCallStatement();
	partial void LeaveRule_funCallStatement();
	// $ANTLR start "funCallStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:73:1: funCallStatement : (name= IDENT '(' a= expression ( ',' b+= expression )* ')' ';' -> ^( FUNC $name $a ( $b)* ) | emptyArgsFun );
	[GrammarRule("funCallStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> funCallStatement()
	{
		EnterRule_funCallStatement();
		EnterRule("funCallStatement", 11);
		TraceIn("funCallStatement", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken name = default(IToken);
		IToken char_literal46 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken char_literal48 = default(IToken);
		IToken char_literal49 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> emptyArgsFun50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree name_tree = default(CommonTree);
		CommonTree char_literal46_tree = default(CommonTree);
		CommonTree char_literal47_tree = default(CommonTree);
		CommonTree char_literal48_tree = default(CommonTree);
		CommonTree char_literal49_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
		RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
		RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "funCallStatement");
		DebugLocation(73, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:2: (name= IDENT '(' a= expression ( ',' b+= expression )* ')' ';' -> ^( FUNC $name $a ( $b)* ) | emptyArgsFun )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==IDENT))
			{
				int LA11_2 = input.LA(2);

				if ((LA11_2==23))
				{
					int LA11_3 = input.LA(3);

					if ((LA11_3==24))
					{
						alt11 = 2;
					}
					else if ((LA11_3==BOOL||LA11_3==FLOAT||(LA11_3>=IDENT && LA11_3<=INTEGER)||LA11_3==STRING||LA11_3==23||LA11_3==26||LA11_3==28||LA11_3==39||LA11_3==49))
					{
						alt11 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:4: name= IDENT '(' a= expression ( ',' b+= expression )* ')' ';'
				{
				DebugLocation(74, 9);
				name=(IToken)Match(input,IDENT,Follow._IDENT_in_funCallStatement313);  
				stream_IDENT.Add(name);

				DebugLocation(74, 17);
				char_literal46=(IToken)Match(input,23,Follow._23_in_funCallStatement315);  
				stream_23.Add(char_literal46);

				DebugLocation(74, 23);
				PushFollow(Follow._expression_in_funCallStatement321);
				a=expression();
				PopFollow();

				stream_expression.Add(a.Tree);
				DebugLocation(74, 36);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:36: ( ',' b+= expression )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1==27))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:37: ',' b+= expression
						{
						DebugLocation(74, 37);
						char_literal47=(IToken)Match(input,27,Follow._27_in_funCallStatement324);  
						stream_27.Add(char_literal47);

						DebugLocation(74, 43);
						PushFollow(Follow._expression_in_funCallStatement330);
						b=expression();
						PopFollow();

						stream_expression.Add(b.Tree);
						if (list_b==null) list_b=new List<CommonTree>();
						list_b.Add(b.Tree);


						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(74, 59);
				char_literal48=(IToken)Match(input,24,Follow._24_in_funCallStatement334);  
				stream_24.Add(char_literal48);

				DebugLocation(74, 63);
				char_literal49=(IToken)Match(input,31,Follow._31_in_funCallStatement336);  
				stream_31.Add(char_literal49);



				{
				// AST REWRITE
				// elements: b, name, a
				// token labels: name
				// rule labels: retval, a
				// token list labels: 
				// rule list labels: b
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
				root_0 = (CommonTree)adaptor.Nil();
				// 74:67: -> ^( FUNC $name $a ( $b)* )
				{
					DebugLocation(74, 70);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:70: ^( FUNC $name $a ( $b)* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(74, 72);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC, "FUNC"), root_1);

					DebugLocation(74, 78);
					adaptor.AddChild(root_1, stream_name.NextNode());
					DebugLocation(74, 84);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(74, 87);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:87: ( $b)*
					while ( stream_b.HasNext )
					{
						DebugLocation(74, 87);
						adaptor.AddChild(root_1, stream_b.NextTree());

					}
					stream_b.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:75:4: emptyArgsFun
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(75, 4);
				PushFollow(Follow._emptyArgsFun_in_funCallStatement357);
				emptyArgsFun50=emptyArgsFun();
				PopFollow();

				adaptor.AddChild(root_0, emptyArgsFun50.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funCallStatement", 11);
			LeaveRule("funCallStatement", 11);
			LeaveRule_funCallStatement();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "funCallStatement"); }
		return retval;

	}
	// $ANTLR end "funCallStatement"

	partial void EnterRule_emptyArgsFun();
	partial void LeaveRule_emptyArgsFun();
	// $ANTLR start "emptyArgsFun"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:83:1: emptyArgsFun : name= IDENT '(' ')' ';' -> ^( FUNC $name) ;
	[GrammarRule("emptyArgsFun")]
	private AstParserRuleReturnScope<CommonTree, IToken> emptyArgsFun()
	{
		EnterRule_emptyArgsFun();
		EnterRule("emptyArgsFun", 12);
		TraceIn("emptyArgsFun", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken name = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken char_literal53 = default(IToken);

		CommonTree name_tree = default(CommonTree);
		CommonTree char_literal51_tree = default(CommonTree);
		CommonTree char_literal52_tree = default(CommonTree);
		CommonTree char_literal53_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
		RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
		try { DebugEnterRule(GrammarFileName, "emptyArgsFun");
		DebugLocation(83, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:2: (name= IDENT '(' ')' ';' -> ^( FUNC $name) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:4: name= IDENT '(' ')' ';'
			{
			DebugLocation(84, 9);
			name=(IToken)Match(input,IDENT,Follow._IDENT_in_emptyArgsFun387);  
			stream_IDENT.Add(name);

			DebugLocation(84, 17);
			char_literal51=(IToken)Match(input,23,Follow._23_in_emptyArgsFun389);  
			stream_23.Add(char_literal51);

			DebugLocation(84, 21);
			char_literal52=(IToken)Match(input,24,Follow._24_in_emptyArgsFun391);  
			stream_24.Add(char_literal52);

			DebugLocation(84, 25);
			char_literal53=(IToken)Match(input,31,Follow._31_in_emptyArgsFun393);  
			stream_31.Add(char_literal53);



			{
			// AST REWRITE
			// elements: name
			// token labels: name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 84:29: -> ^( FUNC $name)
			{
				DebugLocation(84, 32);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:32: ^( FUNC $name)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(84, 34);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(84, 40);
				adaptor.AddChild(root_1, stream_name.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyArgsFun", 12);
			LeaveRule("emptyArgsFun", 12);
			LeaveRule_emptyArgsFun();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyArgsFun"); }
		return retval;

	}
	// $ANTLR end "emptyArgsFun"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:87:1: statement : ( assignmentStatement | whileStatement | ifStatement | funCallStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 13);
		TraceIn("statement", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement56 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> funCallStatement57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(87, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:88:2: ( assignmentStatement | whileStatement | ifStatement | funCallStatement )
			int alt12=4;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA12_2 = input.LA(2);

				if ((LA12_2==34))
				{
					alt12 = 1;
				}
				else if ((LA12_2==23))
				{
					alt12 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 51:
				{
				alt12 = 2;
				}
				break;
			case 47:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:88:4: assignmentStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._assignmentStatement_in_statement414);
				assignmentStatement54=assignmentStatement();
				PopFollow();

				adaptor.AddChild(root_0, assignmentStatement54.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:89:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._whileStatement_in_statement419);
				whileStatement55=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement55.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:90:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._ifStatement_in_statement424);
				ifStatement56=ifStatement();
				PopFollow();

				adaptor.AddChild(root_0, ifStatement56.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:91:4: funCallStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._funCallStatement_in_statement429);
				funCallStatement57=funCallStatement();
				PopFollow();

				adaptor.AddChild(root_0, funCallStatement57.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 13);
			LeaveRule("statement", 13);
			LeaveRule_statement();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_assignmentStatement();
	partial void LeaveRule_assignmentStatement();
	// $ANTLR start "assignmentStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:94:1: assignmentStatement : IDENT '=' ^ expression ';' ;
	[GrammarRule("assignmentStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement()
	{
		EnterRule_assignmentStatement();
		EnterRule("assignmentStatement", 14);
		TraceIn("assignmentStatement", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT58 = default(IToken);
		IToken char_literal59 = default(IToken);
		IToken char_literal61 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT58_tree = default(CommonTree);
		CommonTree char_literal59_tree = default(CommonTree);
		CommonTree char_literal61_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentStatement");
		DebugLocation(94, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:95:2: ( IDENT '=' ^ expression ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:95:4: IDENT '=' ^ expression ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 4);
			IDENT58=(IToken)Match(input,IDENT,Follow._IDENT_in_assignmentStatement440); 
			IDENT58_tree = (CommonTree)adaptor.Create(IDENT58);
			adaptor.AddChild(root_0, IDENT58_tree);
			DebugLocation(95, 13);
			char_literal59=(IToken)Match(input,34,Follow._34_in_assignmentStatement442); 
			char_literal59_tree = (CommonTree)adaptor.Create(char_literal59);
			root_0 = (CommonTree)adaptor.BecomeRoot(char_literal59_tree, root_0);
			DebugLocation(95, 15);
			PushFollow(Follow._expression_in_assignmentStatement445);
			expression60=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression60.Tree);
			DebugLocation(95, 26);
			char_literal61=(IToken)Match(input,31,Follow._31_in_assignmentStatement447); 
			char_literal61_tree = (CommonTree)adaptor.Create(char_literal61);
			adaptor.AddChild(root_0, char_literal61_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentStatement", 14);
			LeaveRule("assignmentStatement", 14);
			LeaveRule_assignmentStatement();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentStatement"); }
		return retval;

	}
	// $ANTLR end "assignmentStatement"

	partial void EnterRule_array();
	partial void LeaveRule_array();
	// $ANTLR start "array"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:98:1: array : ( '[' a= term ( ',' b+= term )* ']' -> ^( ARRAY $a ( $b)* ) | '[' ']' );
	[GrammarRule("array")]
	private AstParserRuleReturnScope<CommonTree, IToken> array()
	{
		EnterRule_array();
		EnterRule("array", 15);
		TraceIn("array", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal62 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken char_literal65 = default(IToken);
		IToken char_literal66 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree char_literal62_tree = default(CommonTree);
		CommonTree char_literal63_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		CommonTree char_literal65_tree = default(CommonTree);
		CommonTree char_literal66_tree = default(CommonTree);
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		try { DebugEnterRule(GrammarFileName, "array");
		DebugLocation(98, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:2: ( '[' a= term ( ',' b+= term )* ']' -> ^( ARRAY $a ( $b)* ) | '[' ']' )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==39))
			{
				int LA14_2 = input.LA(2);

				if ((LA14_2==40))
				{
					alt14 = 2;
				}
				else if ((LA14_2==BOOL||LA14_2==FLOAT||(LA14_2>=IDENT && LA14_2<=INTEGER)||LA14_2==STRING||LA14_2==23||LA14_2==39))
				{
					alt14 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:4: '[' a= term ( ',' b+= term )* ']'
				{
				DebugLocation(99, 4);
				char_literal62=(IToken)Match(input,39,Follow._39_in_array458);  
				stream_39.Add(char_literal62);

				DebugLocation(99, 9);
				PushFollow(Follow._term_in_array463);
				a=term();
				PopFollow();

				stream_term.Add(a.Tree);
				DebugLocation(99, 16);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:16: ( ',' b+= term )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==27))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:17: ',' b+= term
						{
						DebugLocation(99, 17);
						char_literal63=(IToken)Match(input,27,Follow._27_in_array466);  
						stream_27.Add(char_literal63);

						DebugLocation(99, 23);
						PushFollow(Follow._term_in_array472);
						b=term();
						PopFollow();

						stream_term.Add(b.Tree);
						if (list_b==null) list_b=new List<CommonTree>();
						list_b.Add(b.Tree);


						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(99, 32);
				char_literal64=(IToken)Match(input,40,Follow._40_in_array475);  
				stream_40.Add(char_literal64);



				{
				// AST REWRITE
				// elements: b, a
				// token labels: 
				// rule labels: retval, a
				// token list labels: 
				// rule list labels: b
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
				root_0 = (CommonTree)adaptor.Nil();
				// 99:36: -> ^( ARRAY $a ( $b)* )
				{
					DebugLocation(99, 39);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:39: ^( ARRAY $a ( $b)* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(99, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY, "ARRAY"), root_1);

					DebugLocation(99, 48);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(99, 51);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:51: ( $b)*
					while ( stream_b.HasNext )
					{
						DebugLocation(99, 51);
						adaptor.AddChild(root_1, stream_b.NextTree());

					}
					stream_b.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:4: '[' ']'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(100, 4);
				char_literal65=(IToken)Match(input,39,Follow._39_in_array493); 
				char_literal65_tree = (CommonTree)adaptor.Create(char_literal65);
				adaptor.AddChild(root_0, char_literal65_tree);
				DebugLocation(100, 7);
				char_literal66=(IToken)Match(input,40,Follow._40_in_array494); 
				char_literal66_tree = (CommonTree)adaptor.Create(char_literal66);
				adaptor.AddChild(root_0, char_literal66_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array", 15);
			LeaveRule("array", 15);
			LeaveRule_array();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "array"); }
		return retval;

	}
	// $ANTLR end "array"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:107:1: term : ( IDENT | '(' expression ')' -> expression | INTEGER | STRING | BOOL | FLOAT | array );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 16);
		TraceIn("term", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken INTEGER71 = default(IToken);
		IToken STRING72 = default(IToken);
		IToken BOOL73 = default(IToken);
		IToken FLOAT74 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression69 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> array75 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT67_tree = default(CommonTree);
		CommonTree char_literal68_tree = default(CommonTree);
		CommonTree char_literal70_tree = default(CommonTree);
		CommonTree INTEGER71_tree = default(CommonTree);
		CommonTree STRING72_tree = default(CommonTree);
		CommonTree BOOL73_tree = default(CommonTree);
		CommonTree FLOAT74_tree = default(CommonTree);
		RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
		RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(107, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:2: ( IDENT | '(' expression ')' -> expression | INTEGER | STRING | BOOL | FLOAT | array )
			int alt15=7;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt15 = 1;
				}
				break;
			case 23:
				{
				alt15 = 2;
				}
				break;
			case INTEGER:
				{
				alt15 = 3;
				}
				break;
			case STRING:
				{
				alt15 = 4;
				}
				break;
			case BOOL:
				{
				alt15 = 5;
				}
				break;
			case FLOAT:
				{
				alt15 = 6;
				}
				break;
			case 39:
				{
				alt15 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(108, 4);
				IDENT67=(IToken)Match(input,IDENT,Follow._IDENT_in_term518); 
				IDENT67_tree = (CommonTree)adaptor.Create(IDENT67);
				adaptor.AddChild(root_0, IDENT67_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:109:4: '(' expression ')'
				{
				DebugLocation(109, 4);
				char_literal68=(IToken)Match(input,23,Follow._23_in_term523);  
				stream_23.Add(char_literal68);

				DebugLocation(109, 8);
				PushFollow(Follow._expression_in_term525);
				expression69=expression();
				PopFollow();

				stream_expression.Add(expression69.Tree);
				DebugLocation(109, 19);
				char_literal70=(IToken)Match(input,24,Follow._24_in_term527);  
				stream_24.Add(char_literal70);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 109:23: -> expression
				{
					DebugLocation(109, 26);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:110:4: INTEGER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(110, 4);
				INTEGER71=(IToken)Match(input,INTEGER,Follow._INTEGER_in_term536); 
				INTEGER71_tree = (CommonTree)adaptor.Create(INTEGER71);
				adaptor.AddChild(root_0, INTEGER71_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:111:5: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(111, 5);
				STRING72=(IToken)Match(input,STRING,Follow._STRING_in_term542); 
				STRING72_tree = (CommonTree)adaptor.Create(STRING72);
				adaptor.AddChild(root_0, STRING72_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:4: BOOL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(112, 4);
				BOOL73=(IToken)Match(input,BOOL,Follow._BOOL_in_term547); 
				BOOL73_tree = (CommonTree)adaptor.Create(BOOL73);
				adaptor.AddChild(root_0, BOOL73_tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:113:4: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(113, 4);
				FLOAT74=(IToken)Match(input,FLOAT,Follow._FLOAT_in_term552); 
				FLOAT74_tree = (CommonTree)adaptor.Create(FLOAT74);
				adaptor.AddChild(root_0, FLOAT74_tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:4: array
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(114, 4);
				PushFollow(Follow._array_in_term557);
				array75=array();
				PopFollow();

				adaptor.AddChild(root_0, array75.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 16);
			LeaveRule("term", 16);
			LeaveRule_term();
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_negation();
	partial void LeaveRule_negation();
	// $ANTLR start "negation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:117:1: negation : ( 'not' ^)* term ;
	[GrammarRule("negation")]
	private AstParserRuleReturnScope<CommonTree, IToken> negation()
	{
		EnterRule_negation();
		EnterRule("negation", 17);
		TraceIn("negation", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> term77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal76_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "negation");
		DebugLocation(117, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:118:2: ( ( 'not' ^)* term )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:118:4: ( 'not' ^)* term
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(118, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:118:9: ( 'not' ^)*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==49))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:118:9: 'not' ^
					{
					DebugLocation(118, 9);
					string_literal76=(IToken)Match(input,49,Follow._49_in_negation569); 
					string_literal76_tree = (CommonTree)adaptor.Create(string_literal76);
					root_0 = (CommonTree)adaptor.BecomeRoot(string_literal76_tree, root_0);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(118, 12);
			PushFollow(Follow._term_in_negation573);
			term77=term();
			PopFollow();

			adaptor.AddChild(root_0, term77.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negation", 17);
			LeaveRule("negation", 17);
			LeaveRule_negation();
		}
		DebugLocation(119, 1);
		} finally { DebugExitRule(GrammarFileName, "negation"); }
		return retval;

	}
	// $ANTLR end "negation"

	partial void EnterRule_unary();
	partial void LeaveRule_unary();
	// $ANTLR start "unary"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:121:1: unary : ( '+' ^| '-' ^)* negation ;
	[GrammarRule("unary")]
	private AstParserRuleReturnScope<CommonTree, IToken> unary()
	{
		EnterRule_unary();
		EnterRule("unary", 18);
		TraceIn("unary", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal78 = default(IToken);
		IToken char_literal79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> negation80 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal78_tree = default(CommonTree);
		CommonTree char_literal79_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary");
		DebugLocation(121, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:2: ( ( '+' ^| '-' ^)* negation )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:4: ( '+' ^| '-' ^)* negation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(122, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:4: ( '+' ^| '-' ^)*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=3;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==26))
				{
					alt17 = 1;
				}
				else if ((LA17_1==28))
				{
					alt17 = 2;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:5: '+' ^
					{
					DebugLocation(122, 8);
					char_literal78=(IToken)Match(input,26,Follow._26_in_unary587); 
					char_literal78_tree = (CommonTree)adaptor.Create(char_literal78);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal78_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:12: '-' ^
					{
					DebugLocation(122, 15);
					char_literal79=(IToken)Match(input,28,Follow._28_in_unary592); 
					char_literal79_tree = (CommonTree)adaptor.Create(char_literal79);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal79_tree, root_0);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(122, 19);
			PushFollow(Follow._negation_in_unary597);
			negation80=negation();
			PopFollow();

			adaptor.AddChild(root_0, negation80.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary", 18);
			LeaveRule("unary", 18);
			LeaveRule_unary();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "unary"); }
		return retval;

	}
	// $ANTLR end "unary"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:125:1: mult : unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* ;
	[GrammarRule("mult")]
	private AstParserRuleReturnScope<CommonTree, IToken> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 19);
		TraceIn("mult", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal82 = default(IToken);
		IToken char_literal83 = default(IToken);
		IToken string_literal84 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unary81 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unary85 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal82_tree = default(CommonTree);
		CommonTree char_literal83_tree = default(CommonTree);
		CommonTree string_literal84_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(125, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:2: ( unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:4: unary ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(126, 4);
			PushFollow(Follow._unary_in_mult608);
			unary81=unary();
			PopFollow();

			adaptor.AddChild(root_0, unary81.Tree);
			DebugLocation(126, 10);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:10: ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==25||LA19_1==29||LA19_1==48))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:11: ( '*' ^| '/' ^| 'mod' ^) unary
					{
					DebugLocation(126, 11);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:11: ( '*' ^| '/' ^| 'mod' ^)
					int alt18=3;
					try { DebugEnterSubRule(18);
					try { DebugEnterDecision(18, false);
					switch (input.LA(1))
					{
					case 25:
						{
						alt18 = 1;
						}
						break;
					case 29:
						{
						alt18 = 2;
						}
						break;
					case 48:
						{
						alt18 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:12: '*' ^
						{
						DebugLocation(126, 15);
						char_literal82=(IToken)Match(input,25,Follow._25_in_mult612); 
						char_literal82_tree = (CommonTree)adaptor.Create(char_literal82);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal82_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:19: '/' ^
						{
						DebugLocation(126, 22);
						char_literal83=(IToken)Match(input,29,Follow._29_in_mult617); 
						char_literal83_tree = (CommonTree)adaptor.Create(char_literal83);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal83_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:126:26: 'mod' ^
						{
						DebugLocation(126, 31);
						string_literal84=(IToken)Match(input,48,Follow._48_in_mult622); 
						string_literal84_tree = (CommonTree)adaptor.Create(string_literal84);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal84_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(18); }

					DebugLocation(126, 34);
					PushFollow(Follow._unary_in_mult626);
					unary85=unary();
					PopFollow();

					adaptor.AddChild(root_0, unary85.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult", 19);
			LeaveRule("mult", 19);
			LeaveRule_mult();
		}
		DebugLocation(127, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_add();
	partial void LeaveRule_add();
	// $ANTLR start "add"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:129:1: add : mult ( ( '+' ^| '-' ^) mult )* ;
	[GrammarRule("add")]
	private AstParserRuleReturnScope<CommonTree, IToken> add()
	{
		EnterRule_add();
		EnterRule("add", 20);
		TraceIn("add", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal87 = default(IToken);
		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mult86 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mult89 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal87_tree = default(CommonTree);
		CommonTree char_literal88_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(129, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:2: ( mult ( ( '+' ^| '-' ^) mult )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:4: mult ( ( '+' ^| '-' ^) mult )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(130, 4);
			PushFollow(Follow._mult_in_add640);
			mult86=mult();
			PopFollow();

			adaptor.AddChild(root_0, mult86.Tree);
			DebugLocation(130, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:9: ( ( '+' ^| '-' ^) mult )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==26||LA21_1==28))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:10: ( '+' ^| '-' ^) mult
					{
					DebugLocation(130, 10);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:10: ( '+' ^| '-' ^)
					int alt20=2;
					try { DebugEnterSubRule(20);
					try { DebugEnterDecision(20, false);
					int LA20_1 = input.LA(1);

					if ((LA20_1==26))
					{
						alt20 = 1;
					}
					else if ((LA20_1==28))
					{
						alt20 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:11: '+' ^
						{
						DebugLocation(130, 14);
						char_literal87=(IToken)Match(input,26,Follow._26_in_add644); 
						char_literal87_tree = (CommonTree)adaptor.Create(char_literal87);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal87_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:130:18: '-' ^
						{
						DebugLocation(130, 21);
						char_literal88=(IToken)Match(input,28,Follow._28_in_add649); 
						char_literal88_tree = (CommonTree)adaptor.Create(char_literal88);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal88_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(20); }

					DebugLocation(130, 24);
					PushFollow(Follow._mult_in_add653);
					mult89=mult();
					PopFollow();

					adaptor.AddChild(root_0, mult89.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add", 20);
			LeaveRule("add", 20);
			LeaveRule_add();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();
	// $ANTLR start "relation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:133:1: relation : add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 21);
		TraceIn("relation", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal91 = default(IToken);
		IToken string_literal92 = default(IToken);
		IToken char_literal93 = default(IToken);
		IToken string_literal94 = default(IToken);
		IToken string_literal95 = default(IToken);
		IToken char_literal96 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add90 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add97 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal91_tree = default(CommonTree);
		CommonTree string_literal92_tree = default(CommonTree);
		CommonTree char_literal93_tree = default(CommonTree);
		CommonTree string_literal94_tree = default(CommonTree);
		CommonTree string_literal95_tree = default(CommonTree);
		CommonTree char_literal96_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(133, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:2: ( add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:4: add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(134, 4);
			PushFollow(Follow._add_in_relation666);
			add90=add();
			PopFollow();

			adaptor.AddChild(root_0, add90.Tree);
			DebugLocation(134, 8);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:8: ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==21||(LA23_1>=32 && LA23_1<=33)||(LA23_1>=35 && LA23_1<=37)))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:9: ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add
					{
					DebugLocation(134, 9);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:9: ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^)
					int alt22=6;
					try { DebugEnterSubRule(22);
					try { DebugEnterDecision(22, false);
					switch (input.LA(1))
					{
					case 35:
						{
						alt22 = 1;
						}
						break;
					case 21:
						{
						alt22 = 2;
						}
						break;
					case 32:
						{
						alt22 = 3;
						}
						break;
					case 33:
						{
						alt22 = 4;
						}
						break;
					case 37:
						{
						alt22 = 5;
						}
						break;
					case 36:
						{
						alt22 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(22); }
					switch (alt22)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:10: '==' ^
						{
						DebugLocation(134, 14);
						string_literal91=(IToken)Match(input,35,Follow._35_in_relation670); 
						string_literal91_tree = (CommonTree)adaptor.Create(string_literal91);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal91_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:18: '!=' ^
						{
						DebugLocation(134, 22);
						string_literal92=(IToken)Match(input,21,Follow._21_in_relation675); 
						string_literal92_tree = (CommonTree)adaptor.Create(string_literal92);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal92_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:26: '<' ^
						{
						DebugLocation(134, 29);
						char_literal93=(IToken)Match(input,32,Follow._32_in_relation680); 
						char_literal93_tree = (CommonTree)adaptor.Create(char_literal93);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal93_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:33: '<=' ^
						{
						DebugLocation(134, 37);
						string_literal94=(IToken)Match(input,33,Follow._33_in_relation685); 
						string_literal94_tree = (CommonTree)adaptor.Create(string_literal94);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal94_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:41: '>=' ^
						{
						DebugLocation(134, 45);
						string_literal95=(IToken)Match(input,37,Follow._37_in_relation690); 
						string_literal95_tree = (CommonTree)adaptor.Create(string_literal95);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal95_tree, root_0);

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:49: '>' ^
						{
						DebugLocation(134, 52);
						char_literal96=(IToken)Match(input,36,Follow._36_in_relation695); 
						char_literal96_tree = (CommonTree)adaptor.Create(char_literal96);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal96_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(22); }

					DebugLocation(134, 55);
					PushFollow(Follow._add_in_relation699);
					add97=add();
					PopFollow();

					adaptor.AddChild(root_0, add97.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 21);
			LeaveRule("relation", 21);
			LeaveRule_relation();
		}
		DebugLocation(135, 1);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:137:1: expression : relation ( ( '&&' ^| '||' ^) relation )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 22);
		TraceIn("expression", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal99 = default(IToken);
		IToken string_literal100 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relation98 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relation101 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal99_tree = default(CommonTree);
		CommonTree string_literal100_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(137, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:2: ( relation ( ( '&&' ^| '||' ^) relation )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:4: relation ( ( '&&' ^| '||' ^) relation )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(138, 4);
			PushFollow(Follow._relation_in_expression713);
			relation98=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation98.Tree);
			DebugLocation(138, 13);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:13: ( ( '&&' ^| '||' ^) relation )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==22||LA25_1==52))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:14: ( '&&' ^| '||' ^) relation
					{
					DebugLocation(138, 14);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:14: ( '&&' ^| '||' ^)
					int alt24=2;
					try { DebugEnterSubRule(24);
					try { DebugEnterDecision(24, false);
					int LA24_1 = input.LA(1);

					if ((LA24_1==22))
					{
						alt24 = 1;
					}
					else if ((LA24_1==52))
					{
						alt24 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(24); }
					switch (alt24)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:15: '&&' ^
						{
						DebugLocation(138, 19);
						string_literal99=(IToken)Match(input,22,Follow._22_in_expression717); 
						string_literal99_tree = (CommonTree)adaptor.Create(string_literal99);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal99_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:23: '||' ^
						{
						DebugLocation(138, 27);
						string_literal100=(IToken)Match(input,52,Follow._52_in_expression722); 
						string_literal100_tree = (CommonTree)adaptor.Create(string_literal100);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal100_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(24); }

					DebugLocation(138, 30);
					PushFollow(Follow._relation_in_expression726);
					relation101=relation();
					PopFollow();

					adaptor.AddChild(root_0, relation101.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 22);
			LeaveRule("expression", 22);
			LeaveRule_expression();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _41_in_program94 = new BitSet(new ulong[]{0x8A00000002000UL});
		public static readonly BitSet _statement_in_program99 = new BitSet(new ulong[]{0x8A00000002000UL});
		public static readonly BitSet _45_in_program104 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_program106 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_constant119 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _type_in_constant121 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _IDENT_in_constant123 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_constant125 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_constant127 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_constant129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_variable140 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _IDENT_in_variable142 = new BitSet(new ulong[]{0x48000000UL});
		public static readonly BitSet _27_in_variable145 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _IDENT_in_variable147 = new BitSet(new ulong[]{0x48000000UL});
		public static readonly BitSet _30_in_variable151 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _type_in_variable153 = new BitSet(new ulong[]{0x480000000UL});
		public static readonly BitSet _34_in_variable156 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_variable158 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_variable162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _38_in_type174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _47_in_ifStatement186 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_ifStatement189 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_ifStatement191 = new BitSet(new ulong[]{0x8D80000002000UL});
		public static readonly BitSet _statement_in_ifStatement193 = new BitSet(new ulong[]{0x8D80000002000UL});
		public static readonly BitSet _elsif_in_ifStatement196 = new BitSet(new ulong[]{0x580000000000UL});
		public static readonly BitSet _else_g_in_ifStatement199 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _endif_in_ifStatement202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_elsif212 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_elsif215 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_elsif217 = new BitSet(new ulong[]{0x8800000002000UL});
		public static readonly BitSet _statement_in_elsif219 = new BitSet(new ulong[]{0x8800000002002UL});
		public static readonly BitSet _43_in_else_g231 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_else_g234 = new BitSet(new ulong[]{0x8800000002000UL});
		public static readonly BitSet _statement_in_else_g236 = new BitSet(new ulong[]{0x8800000002002UL});
		public static readonly BitSet _46_in_endif248 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_endif250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _51_in_whileStatement262 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _whileBody_in_whileStatement265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_whileBody278 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_whileBody280 = new BitSet(new ulong[]{0x8A00000002000UL});
		public static readonly BitSet _statement_in_whileBody282 = new BitSet(new ulong[]{0x8A00000002000UL});
		public static readonly BitSet _45_in_whileBody285 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_whileBody287 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_whileBody289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_funCallStatement313 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _23_in_funCallStatement315 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_funCallStatement321 = new BitSet(new ulong[]{0x9000000UL});
		public static readonly BitSet _27_in_funCallStatement324 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_funCallStatement330 = new BitSet(new ulong[]{0x9000000UL});
		public static readonly BitSet _24_in_funCallStatement334 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_funCallStatement336 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyArgsFun_in_funCallStatement357 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_emptyArgsFun387 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _23_in_emptyArgsFun389 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _24_in_emptyArgsFun391 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_emptyArgsFun393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentStatement_in_statement414 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement419 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funCallStatement_in_statement429 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignmentStatement440 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_assignmentStatement442 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_assignmentStatement445 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_assignmentStatement447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_array458 = new BitSet(new ulong[]{0x8000846420UL});
		public static readonly BitSet _term_in_array463 = new BitSet(new ulong[]{0x10008000000UL});
		public static readonly BitSet _27_in_array466 = new BitSet(new ulong[]{0x8000846420UL});
		public static readonly BitSet _term_in_array472 = new BitSet(new ulong[]{0x10008000000UL});
		public static readonly BitSet _40_in_array475 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_array493 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _40_in_array494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_term518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_term523 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _expression_in_term525 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _24_in_term527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term536 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOL_in_term547 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_term552 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_in_term557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _49_in_negation569 = new BitSet(new ulong[]{0x2008000846420UL});
		public static readonly BitSet _term_in_negation573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _26_in_unary587 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _28_in_unary592 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _negation_in_unary597 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_in_mult608 = new BitSet(new ulong[]{0x1000022000002UL});
		public static readonly BitSet _25_in_mult612 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _29_in_mult617 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _48_in_mult622 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _unary_in_mult626 = new BitSet(new ulong[]{0x1000022000002UL});
		public static readonly BitSet _mult_in_add640 = new BitSet(new ulong[]{0x14000002UL});
		public static readonly BitSet _26_in_add644 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _28_in_add649 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _mult_in_add653 = new BitSet(new ulong[]{0x14000002UL});
		public static readonly BitSet _add_in_relation666 = new BitSet(new ulong[]{0x3B00200002UL});
		public static readonly BitSet _35_in_relation670 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _21_in_relation675 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _32_in_relation680 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _33_in_relation685 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _37_in_relation690 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _36_in_relation695 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _add_in_relation699 = new BitSet(new ulong[]{0x3B00200002UL});
		public static readonly BitSet _relation_in_expression713 = new BitSet(new ulong[]{0x10000000400002UL});
		public static readonly BitSet _22_in_expression717 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _52_in_expression722 = new BitSet(new ulong[]{0x2008014846420UL});
		public static readonly BitSet _relation_in_expression726 = new BitSet(new ulong[]{0x10000000400002UL});
	}
	#endregion Follow sets
}

} // namespace 
