//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 D:\\Eclipse\\aegiscript_live\\aegiscript.g 2013-03-01 18:14:20

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019





using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace 
    AEGIScript.Lang

{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
//[System.CLSCompliant(false)]
public partial class aegiscriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COMMENT", "DIGIT", "ESC_SEQ", "EXPONENT", "FLOAT", "HEX_DIGIT", "IDENT", "INTEGER", "LETTER", "MULTILINE_COMMENT", "OCTAL_ESC", "STRING", "UNICODE_ESC", "WS", "'('", "')'", "'*'", "'+'", "','", "'-'", "'/'", "'/='", "':'", "';'", "'<'", "'<='", "'='", "'>'", "'>='", "'Integer'", "'and'", "'begin'", "'constant'", "'else'", "'elsif'", "'end'", "'if'", "'mod'", "'not'", "'or'", "'var'", "'while'"
	};
	public const int EOF=-1;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int COMMENT=4;
	public const int DIGIT=5;
	public const int ESC_SEQ=6;
	public const int EXPONENT=7;
	public const int FLOAT=8;
	public const int HEX_DIGIT=9;
	public const int IDENT=10;
	public const int INTEGER=11;
	public const int LETTER=12;
	public const int MULTILINE_COMMENT=13;
	public const int OCTAL_ESC=14;
	public const int STRING=15;
	public const int UNICODE_ESC=16;
	public const int WS=17;

	public aegiscriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public aegiscriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return aegiscriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Eclipse\\aegiscript_live\\aegiscript.g"; } }

	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:31:1: public program : 'begin' ^ ( statement )* 'end' ';' EOF ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal1 = default(IToken);
		IToken string_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);
		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal1_tree = default(CommonTree);
		CommonTree string_literal3_tree = default(CommonTree);
		CommonTree char_literal4_tree = default(CommonTree);
		CommonTree EOF5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(31, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:32:2: ( 'begin' ^ ( statement )* 'end' ';' EOF )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:33:3: 'begin' ^ ( statement )* 'end' ';' EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(33, 10);
			string_literal1=(IToken)Match(input,35,Follow._35_in_program94); 
			string_literal1_tree = (CommonTree)adaptor.Create(string_literal1);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal1_tree, root_0);
			DebugLocation(34, 3);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: ( statement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==IDENT||LA1_1==40||LA1_1==45))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: statement
					{
					DebugLocation(34, 3);
					PushFollow(Follow._statement_in_program99);
					statement2=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement2.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(35, 3);
			string_literal3=(IToken)Match(input,39,Follow._39_in_program104); 
			string_literal3_tree = (CommonTree)adaptor.Create(string_literal3);
			adaptor.AddChild(root_0, string_literal3_tree);
			DebugLocation(35, 9);
			char_literal4=(IToken)Match(input,27,Follow._27_in_program106); 
			char_literal4_tree = (CommonTree)adaptor.Create(char_literal4);
			adaptor.AddChild(root_0, char_literal4_tree);
			DebugLocation(35, 13);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_program108); 
			EOF5_tree = (CommonTree)adaptor.Create(EOF5);
			adaptor.AddChild(root_0, EOF5_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:38:1: constant : 'constant' type IDENT '=' expression ';' ;
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<CommonTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 2);
		TraceIn("constant", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal6 = default(IToken);
		IToken IDENT8 = default(IToken);
		IToken char_literal9 = default(IToken);
		IToken char_literal11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression10 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal6_tree = default(CommonTree);
		CommonTree IDENT8_tree = default(CommonTree);
		CommonTree char_literal9_tree = default(CommonTree);
		CommonTree char_literal11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(38, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:2: ( 'constant' type IDENT '=' expression ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:4: 'constant' type IDENT '=' expression ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(39, 4);
			string_literal6=(IToken)Match(input,36,Follow._36_in_constant119); 
			string_literal6_tree = (CommonTree)adaptor.Create(string_literal6);
			adaptor.AddChild(root_0, string_literal6_tree);
			DebugLocation(39, 15);
			PushFollow(Follow._type_in_constant121);
			type7=type();
			PopFollow();

			adaptor.AddChild(root_0, type7.Tree);
			DebugLocation(39, 20);
			IDENT8=(IToken)Match(input,IDENT,Follow._IDENT_in_constant123); 
			IDENT8_tree = (CommonTree)adaptor.Create(IDENT8);
			adaptor.AddChild(root_0, IDENT8_tree);
			DebugLocation(39, 26);
			char_literal9=(IToken)Match(input,30,Follow._30_in_constant125); 
			char_literal9_tree = (CommonTree)adaptor.Create(char_literal9);
			adaptor.AddChild(root_0, char_literal9_tree);
			DebugLocation(39, 30);
			PushFollow(Follow._expression_in_constant127);
			expression10=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression10.Tree);
			DebugLocation(39, 41);
			char_literal11=(IToken)Match(input,27,Follow._27_in_constant129); 
			char_literal11_tree = (CommonTree)adaptor.Create(char_literal11);
			adaptor.AddChild(root_0, char_literal11_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 2);
			LeaveRule("constant", 2);
			LeaveRule_constant();
		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();
	// $ANTLR start "variable"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:42:1: variable : 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<CommonTree, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal12 = default(IToken);
		IToken IDENT13 = default(IToken);
		IToken char_literal14 = default(IToken);
		IToken IDENT15 = default(IToken);
		IToken char_literal16 = default(IToken);
		IToken char_literal18 = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal12_tree = default(CommonTree);
		CommonTree IDENT13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree IDENT15_tree = default(CommonTree);
		CommonTree char_literal16_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(42, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:2: ( 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:4: 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(43, 4);
			string_literal12=(IToken)Match(input,44,Follow._44_in_variable140); 
			string_literal12_tree = (CommonTree)adaptor.Create(string_literal12);
			adaptor.AddChild(root_0, string_literal12_tree);
			DebugLocation(43, 10);
			IDENT13=(IToken)Match(input,IDENT,Follow._IDENT_in_variable142); 
			IDENT13_tree = (CommonTree)adaptor.Create(IDENT13);
			adaptor.AddChild(root_0, IDENT13_tree);
			DebugLocation(43, 16);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:16: ( ',' IDENT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==22))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:17: ',' IDENT
					{
					DebugLocation(43, 17);
					char_literal14=(IToken)Match(input,22,Follow._22_in_variable145); 
					char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
					adaptor.AddChild(root_0, char_literal14_tree);
					DebugLocation(43, 21);
					IDENT15=(IToken)Match(input,IDENT,Follow._IDENT_in_variable147); 
					IDENT15_tree = (CommonTree)adaptor.Create(IDENT15);
					adaptor.AddChild(root_0, IDENT15_tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(43, 29);
			char_literal16=(IToken)Match(input,26,Follow._26_in_variable151); 
			char_literal16_tree = (CommonTree)adaptor.Create(char_literal16);
			adaptor.AddChild(root_0, char_literal16_tree);
			DebugLocation(43, 33);
			PushFollow(Follow._type_in_variable153);
			type17=type();
			PopFollow();

			adaptor.AddChild(root_0, type17.Tree);
			DebugLocation(43, 38);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:38: ( '=' expression )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==30))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:39: '=' expression
				{
				DebugLocation(43, 39);
				char_literal18=(IToken)Match(input,30,Follow._30_in_variable156); 
				char_literal18_tree = (CommonTree)adaptor.Create(char_literal18);
				adaptor.AddChild(root_0, char_literal18_tree);
				DebugLocation(43, 43);
				PushFollow(Follow._expression_in_variable158);
				expression19=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(43, 56);
			char_literal20=(IToken)Match(input,27,Follow._27_in_variable162); 
			char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
			adaptor.AddChild(root_0, char_literal20_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:46:1: type : 'Integer' ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<CommonTree, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal21 = default(IToken);

		CommonTree string_literal21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(46, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:2: ( 'Integer' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:4: 'Integer'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(47, 4);
			string_literal21=(IToken)Match(input,33,Follow._33_in_type174); 
			string_literal21_tree = (CommonTree)adaptor.Create(string_literal21);
			adaptor.AddChild(root_0, string_literal21_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:50:1: ifStatement : 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 5);
		TraceIn("ifStatement", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal22 = default(IToken);
		IToken char_literal24 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement25 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elsif26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> else_g27 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endif28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal22_tree = default(CommonTree);
		CommonTree char_literal24_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(50, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:2: ( 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:4: 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(51, 8);
			string_literal22=(IToken)Match(input,40,Follow._40_in_ifStatement186); 
			string_literal22_tree = (CommonTree)adaptor.Create(string_literal22);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal22_tree, root_0);
			DebugLocation(51, 10);
			PushFollow(Follow._expression_in_ifStatement189);
			expression23=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression23.Tree);
			DebugLocation(51, 21);
			char_literal24=(IToken)Match(input,26,Follow._26_in_ifStatement191); 
			char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
			adaptor.AddChild(root_0, char_literal24_tree);
			DebugLocation(51, 25);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==IDENT||LA4_1==40||LA4_1==45))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: statement
					{
					DebugLocation(51, 25);
					PushFollow(Follow._statement_in_ifStatement193);
					statement25=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement25.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(51, 36);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: ( elsif )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==38))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: elsif
					{
					DebugLocation(51, 36);
					PushFollow(Follow._elsif_in_ifStatement196);
					elsif26=elsif();
					PopFollow();

					adaptor.AddChild(root_0, elsif26.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(51, 43);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: ( else_g )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==37))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: else_g
				{
				DebugLocation(51, 43);
				PushFollow(Follow._else_g_in_ifStatement199);
				else_g27=else_g();
				PopFollow();

				adaptor.AddChild(root_0, else_g27.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(51, 51);
			PushFollow(Follow._endif_in_ifStatement202);
			endif28=endif();
			PopFollow();

			adaptor.AddChild(root_0, endif28.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 5);
			LeaveRule("ifStatement", 5);
			LeaveRule_ifStatement();
		}
		DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_elsif();
	partial void LeaveRule_elsif();
	// $ANTLR start "elsif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:53:1: elsif : 'elsif' ^ expression ':' ( statement )+ ;
	[GrammarRule("elsif")]
	private AstParserRuleReturnScope<CommonTree, IToken> elsif()
	{
		EnterRule_elsif();
		EnterRule("elsif", 6);
		TraceIn("elsif", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression30 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement32 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal29_tree = default(CommonTree);
		CommonTree char_literal31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "elsif");
		DebugLocation(53, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:2: ( 'elsif' ^ expression ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:4: 'elsif' ^ expression ':' ( statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(54, 11);
			string_literal29=(IToken)Match(input,38,Follow._38_in_elsif212); 
			string_literal29_tree = (CommonTree)adaptor.Create(string_literal29);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal29_tree, root_0);
			DebugLocation(54, 13);
			PushFollow(Follow._expression_in_elsif215);
			expression30=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression30.Tree);
			DebugLocation(54, 24);
			char_literal31=(IToken)Match(input,26,Follow._26_in_elsif217); 
			char_literal31_tree = (CommonTree)adaptor.Create(char_literal31);
			adaptor.AddChild(root_0, char_literal31_tree);
			DebugLocation(54, 28);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: ( statement )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==IDENT||LA7_1==40||LA7_1==45))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: statement
					{
					DebugLocation(54, 28);
					PushFollow(Follow._statement_in_elsif219);
					statement32=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement32.Tree);

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elsif", 6);
			LeaveRule("elsif", 6);
			LeaveRule_elsif();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "elsif"); }
		return retval;

	}
	// $ANTLR end "elsif"

	partial void EnterRule_else_g();
	partial void LeaveRule_else_g();
	// $ANTLR start "else_g"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:56:1: else_g : ( 'else' ^ ':' ( statement )+ ) ;
	[GrammarRule("else_g")]
	private AstParserRuleReturnScope<CommonTree, IToken> else_g()
	{
		EnterRule_else_g();
		EnterRule("else_g", 7);
		TraceIn("else_g", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal33_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "else_g");
		DebugLocation(56, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:2: ( ( 'else' ^ ':' ( statement )+ ) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(57, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:5: 'else' ^ ':' ( statement )+
			{
			DebugLocation(57, 11);
			string_literal33=(IToken)Match(input,37,Follow._37_in_else_g231); 
			string_literal33_tree = (CommonTree)adaptor.Create(string_literal33);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal33_tree, root_0);
			DebugLocation(57, 13);
			char_literal34=(IToken)Match(input,26,Follow._26_in_else_g234); 
			char_literal34_tree = (CommonTree)adaptor.Create(char_literal34);
			adaptor.AddChild(root_0, char_literal34_tree);
			DebugLocation(57, 17);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: ( statement )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==IDENT||LA8_1==40||LA8_1==45))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: statement
					{
					DebugLocation(57, 17);
					PushFollow(Follow._statement_in_else_g236);
					statement35=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement35.Tree);

					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("else_g", 7);
			LeaveRule("else_g", 7);
			LeaveRule_else_g();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "else_g"); }
		return retval;

	}
	// $ANTLR end "else_g"

	partial void EnterRule_endif();
	partial void LeaveRule_endif();
	// $ANTLR start "endif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:59:1: endif : 'end' 'if' ';' ;
	[GrammarRule("endif")]
	private AstParserRuleReturnScope<CommonTree, IToken> endif()
	{
		EnterRule_endif();
		EnterRule("endif", 8);
		TraceIn("endif", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal36 = default(IToken);
		IToken string_literal37 = default(IToken);
		IToken char_literal38 = default(IToken);

		CommonTree string_literal36_tree = default(CommonTree);
		CommonTree string_literal37_tree = default(CommonTree);
		CommonTree char_literal38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "endif");
		DebugLocation(59, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:2: ( 'end' 'if' ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:4: 'end' 'if' ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(60, 4);
			string_literal36=(IToken)Match(input,39,Follow._39_in_endif248); 
			string_literal36_tree = (CommonTree)adaptor.Create(string_literal36);
			adaptor.AddChild(root_0, string_literal36_tree);
			DebugLocation(60, 10);
			string_literal37=(IToken)Match(input,40,Follow._40_in_endif250); 
			string_literal37_tree = (CommonTree)adaptor.Create(string_literal37);
			adaptor.AddChild(root_0, string_literal37_tree);
			DebugLocation(60, 15);
			char_literal38=(IToken)Match(input,27,Follow._27_in_endif252); 
			char_literal38_tree = (CommonTree)adaptor.Create(char_literal38);
			adaptor.AddChild(root_0, char_literal38_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endif", 8);
			LeaveRule("endif", 8);
			LeaveRule_endif();
		}
		DebugLocation(61, 1);
		} finally { DebugExitRule(GrammarFileName, "endif"); }
		return retval;

	}
	// $ANTLR end "endif"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:63:1: whileStatement : 'while' ^ whileBody ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 9);
		TraceIn("whileStatement", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal39 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> whileBody40 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal39_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(63, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:2: ( 'while' ^ whileBody )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:4: 'while' ^ whileBody
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(64, 11);
			string_literal39=(IToken)Match(input,45,Follow._45_in_whileStatement264); 
			string_literal39_tree = (CommonTree)adaptor.Create(string_literal39);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal39_tree, root_0);
			DebugLocation(64, 13);
			PushFollow(Follow._whileBody_in_whileStatement267);
			whileBody40=whileBody();
			PopFollow();

			adaptor.AddChild(root_0, whileBody40.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 9);
			LeaveRule("whileStatement", 9);
			LeaveRule_whileStatement();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_whileBody();
	partial void LeaveRule_whileBody();
	// $ANTLR start "whileBody"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:69:1: whileBody : expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' ;
	[GrammarRule("whileBody")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileBody()
	{
		EnterRule_whileBody();
		EnterRule("whileBody", 10);
		TraceIn("whileBody", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal42 = default(IToken);
		IToken string_literal44 = default(IToken);
		IToken string_literal45 = default(IToken);
		IToken char_literal46 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement43 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal42_tree = default(CommonTree);
		CommonTree string_literal44_tree = default(CommonTree);
		CommonTree string_literal45_tree = default(CommonTree);
		CommonTree char_literal46_tree = default(CommonTree);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileBody");
		DebugLocation(69, 77);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:2: ( expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:4: expression ':' ( statement )* 'end' 'while' ';'
			{
			DebugLocation(70, 4);
			PushFollow(Follow._expression_in_whileBody280);
			expression41=expression();
			PopFollow();

			stream_expression.Add(expression41.Tree);
			DebugLocation(70, 15);
			char_literal42=(IToken)Match(input,26,Follow._26_in_whileBody282);  
			stream_26.Add(char_literal42);

			DebugLocation(70, 19);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: ( statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==IDENT||LA9_1==40||LA9_1==45))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: statement
					{
					DebugLocation(70, 19);
					PushFollow(Follow._statement_in_whileBody284);
					statement43=statement();
					PopFollow();

					stream_statement.Add(statement43.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(70, 30);
			string_literal44=(IToken)Match(input,39,Follow._39_in_whileBody287);  
			stream_39.Add(string_literal44);

			DebugLocation(70, 36);
			string_literal45=(IToken)Match(input,45,Follow._45_in_whileBody289);  
			stream_45.Add(string_literal45);

			DebugLocation(70, 44);
			char_literal46=(IToken)Match(input,27,Follow._27_in_whileBody291);  
			stream_27.Add(char_literal46);



			{
			// AST REWRITE
			// elements: 39, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 70:48: -> expression ( statement )* 'end'
			{
				DebugLocation(70, 51);
				adaptor.AddChild(root_0, stream_expression.NextTree());
				DebugLocation(70, 62);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:62: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(70, 62);
					adaptor.AddChild(root_0, stream_statement.NextTree());

				}
				stream_statement.Reset();
				DebugLocation(70, 73);
				adaptor.AddChild(root_0, stream_39.NextNode());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileBody", 10);
			LeaveRule("whileBody", 10);
			LeaveRule_whileBody();
		}
		DebugLocation(70, 77);
		} finally { DebugExitRule(GrammarFileName, "whileBody"); }
		return retval;

	}
	// $ANTLR end "whileBody"

	partial void EnterRule_funCallStatement();
	partial void LeaveRule_funCallStatement();
	// $ANTLR start "funCallStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:73:1: funCallStatement : IDENT ^ '(' term ( ',' term )* ')' ';' ;
	[GrammarRule("funCallStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> funCallStatement()
	{
		EnterRule_funCallStatement();
		EnterRule("funCallStatement", 11);
		TraceIn("funCallStatement", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT47 = default(IToken);
		IToken char_literal48 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> term49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> term51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT47_tree = default(CommonTree);
		CommonTree char_literal48_tree = default(CommonTree);
		CommonTree char_literal50_tree = default(CommonTree);
		CommonTree char_literal52_tree = default(CommonTree);
		CommonTree char_literal53_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "funCallStatement");
		DebugLocation(73, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:2: ( IDENT ^ '(' term ( ',' term )* ')' ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:4: IDENT ^ '(' term ( ',' term )* ')' ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 9);
			IDENT47=(IToken)Match(input,IDENT,Follow._IDENT_in_funCallStatement311); 
			IDENT47_tree = (CommonTree)adaptor.Create(IDENT47);
			root_0 = (CommonTree)adaptor.BecomeRoot(IDENT47_tree, root_0);
			DebugLocation(74, 11);
			char_literal48=(IToken)Match(input,18,Follow._18_in_funCallStatement314); 
			char_literal48_tree = (CommonTree)adaptor.Create(char_literal48);
			adaptor.AddChild(root_0, char_literal48_tree);
			DebugLocation(74, 15);
			PushFollow(Follow._term_in_funCallStatement316);
			term49=term();
			PopFollow();

			adaptor.AddChild(root_0, term49.Tree);
			DebugLocation(74, 20);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:20: ( ',' term )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==22))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:21: ',' term
					{
					DebugLocation(74, 21);
					char_literal50=(IToken)Match(input,22,Follow._22_in_funCallStatement319); 
					char_literal50_tree = (CommonTree)adaptor.Create(char_literal50);
					adaptor.AddChild(root_0, char_literal50_tree);
					DebugLocation(74, 25);
					PushFollow(Follow._term_in_funCallStatement321);
					term51=term();
					PopFollow();

					adaptor.AddChild(root_0, term51.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(74, 32);
			char_literal52=(IToken)Match(input,19,Follow._19_in_funCallStatement325); 
			char_literal52_tree = (CommonTree)adaptor.Create(char_literal52);
			adaptor.AddChild(root_0, char_literal52_tree);
			DebugLocation(74, 36);
			char_literal53=(IToken)Match(input,27,Follow._27_in_funCallStatement327); 
			char_literal53_tree = (CommonTree)adaptor.Create(char_literal53);
			adaptor.AddChild(root_0, char_literal53_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funCallStatement", 11);
			LeaveRule("funCallStatement", 11);
			LeaveRule_funCallStatement();
		}
		DebugLocation(75, 1);
		} finally { DebugExitRule(GrammarFileName, "funCallStatement"); }
		return retval;

	}
	// $ANTLR end "funCallStatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:77:1: statement : ( assignmentStatement | whileStatement | ifStatement | funCallStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 12);
		TraceIn("statement", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement56 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> funCallStatement57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(77, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:78:2: ( assignmentStatement | whileStatement | ifStatement | funCallStatement )
			int alt11=4;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA11_2 = input.LA(2);

				if ((LA11_2==30))
				{
					alt11 = 1;
				}
				else if ((LA11_2==18))
				{
					alt11 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 45:
				{
				alt11 = 2;
				}
				break;
			case 40:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:78:4: assignmentStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(78, 4);
				PushFollow(Follow._assignmentStatement_in_statement338);
				assignmentStatement54=assignmentStatement();
				PopFollow();

				adaptor.AddChild(root_0, assignmentStatement54.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:79:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(79, 4);
				PushFollow(Follow._whileStatement_in_statement343);
				whileStatement55=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement55.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:80:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(80, 4);
				PushFollow(Follow._ifStatement_in_statement348);
				ifStatement56=ifStatement();
				PopFollow();

				adaptor.AddChild(root_0, ifStatement56.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:81:4: funCallStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(81, 4);
				PushFollow(Follow._funCallStatement_in_statement353);
				funCallStatement57=funCallStatement();
				PopFollow();

				adaptor.AddChild(root_0, funCallStatement57.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 12);
			LeaveRule("statement", 12);
			LeaveRule_statement();
		}
		DebugLocation(82, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_assignmentStatement();
	partial void LeaveRule_assignmentStatement();
	// $ANTLR start "assignmentStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:1: assignmentStatement : IDENT '=' ^ expression ';' ;
	[GrammarRule("assignmentStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement()
	{
		EnterRule_assignmentStatement();
		EnterRule("assignmentStatement", 13);
		TraceIn("assignmentStatement", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT58 = default(IToken);
		IToken char_literal59 = default(IToken);
		IToken char_literal61 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT58_tree = default(CommonTree);
		CommonTree char_literal59_tree = default(CommonTree);
		CommonTree char_literal61_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentStatement");
		DebugLocation(84, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:85:2: ( IDENT '=' ^ expression ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:85:4: IDENT '=' ^ expression ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(85, 4);
			IDENT58=(IToken)Match(input,IDENT,Follow._IDENT_in_assignmentStatement364); 
			IDENT58_tree = (CommonTree)adaptor.Create(IDENT58);
			adaptor.AddChild(root_0, IDENT58_tree);
			DebugLocation(85, 13);
			char_literal59=(IToken)Match(input,30,Follow._30_in_assignmentStatement366); 
			char_literal59_tree = (CommonTree)adaptor.Create(char_literal59);
			root_0 = (CommonTree)adaptor.BecomeRoot(char_literal59_tree, root_0);
			DebugLocation(85, 15);
			PushFollow(Follow._expression_in_assignmentStatement369);
			expression60=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression60.Tree);
			DebugLocation(85, 26);
			char_literal61=(IToken)Match(input,27,Follow._27_in_assignmentStatement371); 
			char_literal61_tree = (CommonTree)adaptor.Create(char_literal61);
			adaptor.AddChild(root_0, char_literal61_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentStatement", 13);
			LeaveRule("assignmentStatement", 13);
			LeaveRule_assignmentStatement();
		}
		DebugLocation(86, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentStatement"); }
		return retval;

	}
	// $ANTLR end "assignmentStatement"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:88:1: term : ( IDENT | '(' expression ')' -> expression | INTEGER | STRING );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 14);
		TraceIn("term", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT62 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal65 = default(IToken);
		IToken INTEGER66 = default(IToken);
		IToken STRING67 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT62_tree = default(CommonTree);
		CommonTree char_literal63_tree = default(CommonTree);
		CommonTree char_literal65_tree = default(CommonTree);
		CommonTree INTEGER66_tree = default(CommonTree);
		CommonTree STRING67_tree = default(CommonTree);
		RewriteRuleITokenStream stream_19=new RewriteRuleITokenStream(adaptor,"token 19");
		RewriteRuleITokenStream stream_18=new RewriteRuleITokenStream(adaptor,"token 18");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(88, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:89:2: ( IDENT | '(' expression ')' -> expression | INTEGER | STRING )
			int alt12=4;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt12 = 1;
				}
				break;
			case 18:
				{
				alt12 = 2;
				}
				break;
			case INTEGER:
				{
				alt12 = 3;
				}
				break;
			case STRING:
				{
				alt12 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:89:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 4);
				IDENT62=(IToken)Match(input,IDENT,Follow._IDENT_in_term384); 
				IDENT62_tree = (CommonTree)adaptor.Create(IDENT62);
				adaptor.AddChild(root_0, IDENT62_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:90:4: '(' expression ')'
				{
				DebugLocation(90, 4);
				char_literal63=(IToken)Match(input,18,Follow._18_in_term389);  
				stream_18.Add(char_literal63);

				DebugLocation(90, 8);
				PushFollow(Follow._expression_in_term391);
				expression64=expression();
				PopFollow();

				stream_expression.Add(expression64.Tree);
				DebugLocation(90, 19);
				char_literal65=(IToken)Match(input,19,Follow._19_in_term393);  
				stream_19.Add(char_literal65);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 90:23: -> expression
				{
					DebugLocation(90, 26);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:91:4: INTEGER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(91, 4);
				INTEGER66=(IToken)Match(input,INTEGER,Follow._INTEGER_in_term402); 
				INTEGER66_tree = (CommonTree)adaptor.Create(INTEGER66);
				adaptor.AddChild(root_0, INTEGER66_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:92:5: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(92, 5);
				STRING67=(IToken)Match(input,STRING,Follow._STRING_in_term408); 
				STRING67_tree = (CommonTree)adaptor.Create(STRING67);
				adaptor.AddChild(root_0, STRING67_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 14);
			LeaveRule("term", 14);
			LeaveRule_term();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_negation();
	partial void LeaveRule_negation();
	// $ANTLR start "negation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:95:1: negation : ( 'not' ^)* term ;
	[GrammarRule("negation")]
	private AstParserRuleReturnScope<CommonTree, IToken> negation()
	{
		EnterRule_negation();
		EnterRule("negation", 15);
		TraceIn("negation", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal68 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> term69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal68_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "negation");
		DebugLocation(95, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:2: ( ( 'not' ^)* term )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:4: ( 'not' ^)* term
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(96, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:9: ( 'not' ^)*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==42))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:9: 'not' ^
					{
					DebugLocation(96, 9);
					string_literal68=(IToken)Match(input,42,Follow._42_in_negation420); 
					string_literal68_tree = (CommonTree)adaptor.Create(string_literal68);
					root_0 = (CommonTree)adaptor.BecomeRoot(string_literal68_tree, root_0);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(96, 12);
			PushFollow(Follow._term_in_negation424);
			term69=term();
			PopFollow();

			adaptor.AddChild(root_0, term69.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negation", 15);
			LeaveRule("negation", 15);
			LeaveRule_negation();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "negation"); }
		return retval;

	}
	// $ANTLR end "negation"

	partial void EnterRule_unary();
	partial void LeaveRule_unary();
	// $ANTLR start "unary"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:1: unary : ( '+' ^| '-' ^)* negation ;
	[GrammarRule("unary")]
	private AstParserRuleReturnScope<CommonTree, IToken> unary()
	{
		EnterRule_unary();
		EnterRule("unary", 16);
		TraceIn("unary", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal70 = default(IToken);
		IToken char_literal71 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> negation72 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal70_tree = default(CommonTree);
		CommonTree char_literal71_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary");
		DebugLocation(99, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:2: ( ( '+' ^| '-' ^)* negation )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:4: ( '+' ^| '-' ^)* negation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(100, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:4: ( '+' ^| '-' ^)*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=3;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==21))
				{
					alt14 = 1;
				}
				else if ((LA14_1==23))
				{
					alt14 = 2;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:5: '+' ^
					{
					DebugLocation(100, 8);
					char_literal70=(IToken)Match(input,21,Follow._21_in_unary438); 
					char_literal70_tree = (CommonTree)adaptor.Create(char_literal70);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal70_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:12: '-' ^
					{
					DebugLocation(100, 15);
					char_literal71=(IToken)Match(input,23,Follow._23_in_unary443); 
					char_literal71_tree = (CommonTree)adaptor.Create(char_literal71);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal71_tree, root_0);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(100, 19);
			PushFollow(Follow._negation_in_unary448);
			negation72=negation();
			PopFollow();

			adaptor.AddChild(root_0, negation72.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary", 16);
			LeaveRule("unary", 16);
			LeaveRule_unary();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "unary"); }
		return retval;

	}
	// $ANTLR end "unary"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:103:1: mult : unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* ;
	[GrammarRule("mult")]
	private AstParserRuleReturnScope<CommonTree, IToken> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 17);
		TraceIn("mult", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken string_literal76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unary73 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unary77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal74_tree = default(CommonTree);
		CommonTree char_literal75_tree = default(CommonTree);
		CommonTree string_literal76_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(103, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:2: ( unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:4: unary ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(104, 4);
			PushFollow(Follow._unary_in_mult459);
			unary73=unary();
			PopFollow();

			adaptor.AddChild(root_0, unary73.Tree);
			DebugLocation(104, 10);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:10: ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==20||LA16_1==24||LA16_1==41))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:11: ( '*' ^| '/' ^| 'mod' ^) unary
					{
					DebugLocation(104, 11);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:11: ( '*' ^| '/' ^| 'mod' ^)
					int alt15=3;
					try { DebugEnterSubRule(15);
					try { DebugEnterDecision(15, false);
					switch (input.LA(1))
					{
					case 20:
						{
						alt15 = 1;
						}
						break;
					case 24:
						{
						alt15 = 2;
						}
						break;
					case 41:
						{
						alt15 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:12: '*' ^
						{
						DebugLocation(104, 15);
						char_literal74=(IToken)Match(input,20,Follow._20_in_mult463); 
						char_literal74_tree = (CommonTree)adaptor.Create(char_literal74);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal74_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:19: '/' ^
						{
						DebugLocation(104, 22);
						char_literal75=(IToken)Match(input,24,Follow._24_in_mult468); 
						char_literal75_tree = (CommonTree)adaptor.Create(char_literal75);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal75_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:104:26: 'mod' ^
						{
						DebugLocation(104, 31);
						string_literal76=(IToken)Match(input,41,Follow._41_in_mult473); 
						string_literal76_tree = (CommonTree)adaptor.Create(string_literal76);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal76_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(15); }

					DebugLocation(104, 34);
					PushFollow(Follow._unary_in_mult477);
					unary77=unary();
					PopFollow();

					adaptor.AddChild(root_0, unary77.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult", 17);
			LeaveRule("mult", 17);
			LeaveRule_mult();
		}
		DebugLocation(105, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_add();
	partial void LeaveRule_add();
	// $ANTLR start "add"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:107:1: add : mult ( ( '+' ^| '-' ^) mult )* ;
	[GrammarRule("add")]
	private AstParserRuleReturnScope<CommonTree, IToken> add()
	{
		EnterRule_add();
		EnterRule("add", 18);
		TraceIn("add", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal79 = default(IToken);
		IToken char_literal80 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mult78 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mult81 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal79_tree = default(CommonTree);
		CommonTree char_literal80_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(107, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:2: ( mult ( ( '+' ^| '-' ^) mult )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:4: mult ( ( '+' ^| '-' ^) mult )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(108, 4);
			PushFollow(Follow._mult_in_add491);
			mult78=mult();
			PopFollow();

			adaptor.AddChild(root_0, mult78.Tree);
			DebugLocation(108, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:9: ( ( '+' ^| '-' ^) mult )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==21||LA18_1==23))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:10: ( '+' ^| '-' ^) mult
					{
					DebugLocation(108, 10);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:10: ( '+' ^| '-' ^)
					int alt17=2;
					try { DebugEnterSubRule(17);
					try { DebugEnterDecision(17, false);
					int LA17_1 = input.LA(1);

					if ((LA17_1==21))
					{
						alt17 = 1;
					}
					else if ((LA17_1==23))
					{
						alt17 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(17); }
					switch (alt17)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:11: '+' ^
						{
						DebugLocation(108, 14);
						char_literal79=(IToken)Match(input,21,Follow._21_in_add495); 
						char_literal79_tree = (CommonTree)adaptor.Create(char_literal79);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal79_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:108:18: '-' ^
						{
						DebugLocation(108, 21);
						char_literal80=(IToken)Match(input,23,Follow._23_in_add500); 
						char_literal80_tree = (CommonTree)adaptor.Create(char_literal80);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal80_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(17); }

					DebugLocation(108, 24);
					PushFollow(Follow._mult_in_add504);
					mult81=mult();
					PopFollow();

					adaptor.AddChild(root_0, mult81.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add", 18);
			LeaveRule("add", 18);
			LeaveRule_add();
		}
		DebugLocation(109, 1);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();
	// $ANTLR start "relation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:111:1: relation : add ( ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 19);
		TraceIn("relation", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal83 = default(IToken);
		IToken string_literal84 = default(IToken);
		IToken char_literal85 = default(IToken);
		IToken string_literal86 = default(IToken);
		IToken string_literal87 = default(IToken);
		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add82 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add89 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal83_tree = default(CommonTree);
		CommonTree string_literal84_tree = default(CommonTree);
		CommonTree char_literal85_tree = default(CommonTree);
		CommonTree string_literal86_tree = default(CommonTree);
		CommonTree string_literal87_tree = default(CommonTree);
		CommonTree char_literal88_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(111, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:2: ( add ( ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:4: add ( ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(112, 4);
			PushFollow(Follow._add_in_relation517);
			add82=add();
			PopFollow();

			adaptor.AddChild(root_0, add82.Tree);
			DebugLocation(112, 8);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:8: ( ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==25||(LA20_1>=28 && LA20_1<=32)))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:9: ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add
					{
					DebugLocation(112, 9);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:9: ( '=' ^| '/=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^)
					int alt19=6;
					try { DebugEnterSubRule(19);
					try { DebugEnterDecision(19, false);
					switch (input.LA(1))
					{
					case 30:
						{
						alt19 = 1;
						}
						break;
					case 25:
						{
						alt19 = 2;
						}
						break;
					case 28:
						{
						alt19 = 3;
						}
						break;
					case 29:
						{
						alt19 = 4;
						}
						break;
					case 32:
						{
						alt19 = 5;
						}
						break;
					case 31:
						{
						alt19 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:10: '=' ^
						{
						DebugLocation(112, 13);
						char_literal83=(IToken)Match(input,30,Follow._30_in_relation521); 
						char_literal83_tree = (CommonTree)adaptor.Create(char_literal83);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal83_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:17: '/=' ^
						{
						DebugLocation(112, 21);
						string_literal84=(IToken)Match(input,25,Follow._25_in_relation526); 
						string_literal84_tree = (CommonTree)adaptor.Create(string_literal84);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal84_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:25: '<' ^
						{
						DebugLocation(112, 28);
						char_literal85=(IToken)Match(input,28,Follow._28_in_relation531); 
						char_literal85_tree = (CommonTree)adaptor.Create(char_literal85);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal85_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:32: '<=' ^
						{
						DebugLocation(112, 36);
						string_literal86=(IToken)Match(input,29,Follow._29_in_relation536); 
						string_literal86_tree = (CommonTree)adaptor.Create(string_literal86);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal86_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:40: '>=' ^
						{
						DebugLocation(112, 44);
						string_literal87=(IToken)Match(input,32,Follow._32_in_relation541); 
						string_literal87_tree = (CommonTree)adaptor.Create(string_literal87);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal87_tree, root_0);

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:112:48: '>' ^
						{
						DebugLocation(112, 51);
						char_literal88=(IToken)Match(input,31,Follow._31_in_relation546); 
						char_literal88_tree = (CommonTree)adaptor.Create(char_literal88);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal88_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(19); }

					DebugLocation(112, 54);
					PushFollow(Follow._add_in_relation550);
					add89=add();
					PopFollow();

					adaptor.AddChild(root_0, add89.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 19);
			LeaveRule("relation", 19);
			LeaveRule_relation();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:115:1: expression : relation ( ( 'and' ^| 'or' ^) relation )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 20);
		TraceIn("expression", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal91 = default(IToken);
		IToken string_literal92 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relation90 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relation93 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal91_tree = default(CommonTree);
		CommonTree string_literal92_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(115, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:2: ( relation ( ( 'and' ^| 'or' ^) relation )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:4: relation ( ( 'and' ^| 'or' ^) relation )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(116, 4);
			PushFollow(Follow._relation_in_expression564);
			relation90=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation90.Tree);
			DebugLocation(116, 13);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:13: ( ( 'and' ^| 'or' ^) relation )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==34||LA22_1==43))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:14: ( 'and' ^| 'or' ^) relation
					{
					DebugLocation(116, 14);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:14: ( 'and' ^| 'or' ^)
					int alt21=2;
					try { DebugEnterSubRule(21);
					try { DebugEnterDecision(21, false);
					int LA21_1 = input.LA(1);

					if ((LA21_1==34))
					{
						alt21 = 1;
					}
					else if ((LA21_1==43))
					{
						alt21 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:15: 'and' ^
						{
						DebugLocation(116, 20);
						string_literal91=(IToken)Match(input,34,Follow._34_in_expression568); 
						string_literal91_tree = (CommonTree)adaptor.Create(string_literal91);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal91_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:116:24: 'or' ^
						{
						DebugLocation(116, 28);
						string_literal92=(IToken)Match(input,43,Follow._43_in_expression573); 
						string_literal92_tree = (CommonTree)adaptor.Create(string_literal92);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal92_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(21); }

					DebugLocation(116, 31);
					PushFollow(Follow._relation_in_expression577);
					relation93=relation();
					PopFollow();

					adaptor.AddChild(root_0, relation93.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 20);
			LeaveRule("expression", 20);
			LeaveRule_expression();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _35_in_program94 = new BitSet(new ulong[]{0x218000000400UL});
		public static readonly BitSet _statement_in_program99 = new BitSet(new ulong[]{0x218000000400UL});
		public static readonly BitSet _39_in_program104 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_program106 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _36_in_constant119 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _type_in_constant121 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _IDENT_in_constant123 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_constant125 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_constant127 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_constant129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_variable140 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _IDENT_in_variable142 = new BitSet(new ulong[]{0x4400000UL});
		public static readonly BitSet _22_in_variable145 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _IDENT_in_variable147 = new BitSet(new ulong[]{0x4400000UL});
		public static readonly BitSet _26_in_variable151 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _type_in_variable153 = new BitSet(new ulong[]{0x48000000UL});
		public static readonly BitSet _30_in_variable156 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_variable158 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_variable162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_type174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _40_in_ifStatement186 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_ifStatement189 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_ifStatement191 = new BitSet(new ulong[]{0x21E000000400UL});
		public static readonly BitSet _statement_in_ifStatement193 = new BitSet(new ulong[]{0x21E000000400UL});
		public static readonly BitSet _elsif_in_ifStatement196 = new BitSet(new ulong[]{0xE000000000UL});
		public static readonly BitSet _else_g_in_ifStatement199 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _endif_in_ifStatement202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _38_in_elsif212 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_elsif215 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_elsif217 = new BitSet(new ulong[]{0x210000000400UL});
		public static readonly BitSet _statement_in_elsif219 = new BitSet(new ulong[]{0x210000000402UL});
		public static readonly BitSet _37_in_else_g231 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_else_g234 = new BitSet(new ulong[]{0x210000000400UL});
		public static readonly BitSet _statement_in_else_g236 = new BitSet(new ulong[]{0x210000000402UL});
		public static readonly BitSet _39_in_endif248 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _40_in_endif250 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_endif252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_whileStatement264 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _whileBody_in_whileStatement267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_whileBody280 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_whileBody282 = new BitSet(new ulong[]{0x218000000400UL});
		public static readonly BitSet _statement_in_whileBody284 = new BitSet(new ulong[]{0x218000000400UL});
		public static readonly BitSet _39_in_whileBody287 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _45_in_whileBody289 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_whileBody291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_funCallStatement311 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _18_in_funCallStatement314 = new BitSet(new ulong[]{0x48C00UL});
		public static readonly BitSet _term_in_funCallStatement316 = new BitSet(new ulong[]{0x480000UL});
		public static readonly BitSet _22_in_funCallStatement319 = new BitSet(new ulong[]{0x48C00UL});
		public static readonly BitSet _term_in_funCallStatement321 = new BitSet(new ulong[]{0x480000UL});
		public static readonly BitSet _19_in_funCallStatement325 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_funCallStatement327 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentStatement_in_statement338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement343 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funCallStatement_in_statement353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignmentStatement364 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_assignmentStatement366 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_assignmentStatement369 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_assignmentStatement371 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_term384 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_term389 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _expression_in_term391 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_term393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term402 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_negation420 = new BitSet(new ulong[]{0x40000048C00UL});
		public static readonly BitSet _term_in_negation424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_unary438 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _23_in_unary443 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _negation_in_unary448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_in_mult459 = new BitSet(new ulong[]{0x20001100002UL});
		public static readonly BitSet _20_in_mult463 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _24_in_mult468 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _41_in_mult473 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _unary_in_mult477 = new BitSet(new ulong[]{0x20001100002UL});
		public static readonly BitSet _mult_in_add491 = new BitSet(new ulong[]{0xA00002UL});
		public static readonly BitSet _21_in_add495 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _23_in_add500 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _mult_in_add504 = new BitSet(new ulong[]{0xA00002UL});
		public static readonly BitSet _add_in_relation517 = new BitSet(new ulong[]{0x1F2000002UL});
		public static readonly BitSet _30_in_relation521 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _25_in_relation526 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _28_in_relation531 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _29_in_relation536 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _32_in_relation541 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _31_in_relation546 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _add_in_relation550 = new BitSet(new ulong[]{0x1F2000002UL});
		public static readonly BitSet _relation_in_expression564 = new BitSet(new ulong[]{0x80400000002UL});
		public static readonly BitSet _34_in_expression568 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _43_in_expression573 = new BitSet(new ulong[]{0x40000A48C00UL});
		public static readonly BitSet _relation_in_expression577 = new BitSet(new ulong[]{0x80400000002UL});
	}
	#endregion Follow sets
}

} // namespace 
