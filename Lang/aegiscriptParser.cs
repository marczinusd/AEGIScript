//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 D:\\Eclipse\\aegiscript_live\\aegiscript.g 2013-04-24 20:03:38

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019





using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace 
    AEGIScript.Lang

{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class aegiscriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACCESS", "ARRAY", "BOOL", "COMMENT", "DIGIT", "ESC_SEQ", "EXPONENT", "FIELD_ACCESS", "FLOAT", "FUNC", "HEX_DIGIT", "IDENT", "INTEGER", "LETTER", "MULTILINE_COMMENT", "OCTAL_ESC", "STRING", "UNICODE_ESC", "WS", "'!='", "'&&'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'/'", "':'", "';'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'Integer'", "'['", "']'", "'begin'", "'constant'", "'else'", "'elsif'", "'end'", "'endif'", "'if'", "'mod'", "'not'", "'var'", "'while'", "'||'"
	};
	public const int EOF=-1;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int ACCESS=4;
	public const int ARRAY=5;
	public const int BOOL=6;
	public const int COMMENT=7;
	public const int DIGIT=8;
	public const int ESC_SEQ=9;
	public const int EXPONENT=10;
	public const int FIELD_ACCESS=11;
	public const int FLOAT=12;
	public const int FUNC=13;
	public const int HEX_DIGIT=14;
	public const int IDENT=15;
	public const int INTEGER=16;
	public const int LETTER=17;
	public const int MULTILINE_COMMENT=18;
	public const int OCTAL_ESC=19;
	public const int STRING=20;
	public const int UNICODE_ESC=21;
	public const int WS=22;

	public aegiscriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public aegiscriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return aegiscriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Eclipse\\aegiscript_live\\aegiscript.g"; } }

	int HIDDEN = Hidden;

	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:31:1: public program : 'begin' ^ ( statement )* 'end' ';' EOF ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal1 = default(IToken);
		IToken string_literal3 = default(IToken);
		IToken char_literal4 = default(IToken);
		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal1_tree = default(CommonTree);
		CommonTree string_literal3_tree = default(CommonTree);
		CommonTree char_literal4_tree = default(CommonTree);
		CommonTree EOF5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(31, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:32:2: ( 'begin' ^ ( statement )* 'end' ';' EOF )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:33:3: 'begin' ^ ( statement )* 'end' ';' EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(33, 10);
			string_literal1=(IToken)Match(input,44,Follow._44_in_program94); 
			string_literal1_tree = (CommonTree)adaptor.Create(string_literal1);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal1_tree, root_0);
			DebugLocation(34, 3);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: ( statement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==IDENT||LA1_1==50||LA1_1==54))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:34:3: statement
					{
					DebugLocation(34, 3);
					PushFollow(Follow._statement_in_program99);
					statement2=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement2.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(35, 3);
			string_literal3=(IToken)Match(input,48,Follow._48_in_program104); 
			string_literal3_tree = (CommonTree)adaptor.Create(string_literal3);
			adaptor.AddChild(root_0, string_literal3_tree);
			DebugLocation(35, 9);
			char_literal4=(IToken)Match(input,34,Follow._34_in_program106); 
			char_literal4_tree = (CommonTree)adaptor.Create(char_literal4);
			adaptor.AddChild(root_0, char_literal4_tree);
			DebugLocation(35, 13);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_program108); 
			EOF5_tree = (CommonTree)adaptor.Create(EOF5);
			adaptor.AddChild(root_0, EOF5_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:38:1: constant : 'constant' type IDENT '=' expression ';' ;
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<CommonTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 2);
		TraceIn("constant", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal6 = default(IToken);
		IToken IDENT8 = default(IToken);
		IToken char_literal9 = default(IToken);
		IToken char_literal11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression10 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal6_tree = default(CommonTree);
		CommonTree IDENT8_tree = default(CommonTree);
		CommonTree char_literal9_tree = default(CommonTree);
		CommonTree char_literal11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(38, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:2: ( 'constant' type IDENT '=' expression ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:39:4: 'constant' type IDENT '=' expression ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(39, 4);
			string_literal6=(IToken)Match(input,45,Follow._45_in_constant119); 
			string_literal6_tree = (CommonTree)adaptor.Create(string_literal6);
			adaptor.AddChild(root_0, string_literal6_tree);
			DebugLocation(39, 15);
			PushFollow(Follow._type_in_constant121);
			type7=type();
			PopFollow();

			adaptor.AddChild(root_0, type7.Tree);
			DebugLocation(39, 20);
			IDENT8=(IToken)Match(input,IDENT,Follow._IDENT_in_constant123); 
			IDENT8_tree = (CommonTree)adaptor.Create(IDENT8);
			adaptor.AddChild(root_0, IDENT8_tree);
			DebugLocation(39, 26);
			char_literal9=(IToken)Match(input,37,Follow._37_in_constant125); 
			char_literal9_tree = (CommonTree)adaptor.Create(char_literal9);
			adaptor.AddChild(root_0, char_literal9_tree);
			DebugLocation(39, 30);
			PushFollow(Follow._expression_in_constant127);
			expression10=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression10.Tree);
			DebugLocation(39, 41);
			char_literal11=(IToken)Match(input,34,Follow._34_in_constant129); 
			char_literal11_tree = (CommonTree)adaptor.Create(char_literal11);
			adaptor.AddChild(root_0, char_literal11_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 2);
			LeaveRule("constant", 2);
			LeaveRule_constant();
		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();
	// $ANTLR start "variable"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:42:1: variable : 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<CommonTree, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal12 = default(IToken);
		IToken IDENT13 = default(IToken);
		IToken char_literal14 = default(IToken);
		IToken IDENT15 = default(IToken);
		IToken char_literal16 = default(IToken);
		IToken char_literal18 = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal12_tree = default(CommonTree);
		CommonTree IDENT13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree IDENT15_tree = default(CommonTree);
		CommonTree char_literal16_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(42, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:2: ( 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:4: 'var' IDENT ( ',' IDENT )* ':' type ( '=' expression )? ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(43, 4);
			string_literal12=(IToken)Match(input,53,Follow._53_in_variable140); 
			string_literal12_tree = (CommonTree)adaptor.Create(string_literal12);
			adaptor.AddChild(root_0, string_literal12_tree);
			DebugLocation(43, 10);
			IDENT13=(IToken)Match(input,IDENT,Follow._IDENT_in_variable142); 
			IDENT13_tree = (CommonTree)adaptor.Create(IDENT13);
			adaptor.AddChild(root_0, IDENT13_tree);
			DebugLocation(43, 16);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:16: ( ',' IDENT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==29))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:17: ',' IDENT
					{
					DebugLocation(43, 17);
					char_literal14=(IToken)Match(input,29,Follow._29_in_variable145); 
					char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
					adaptor.AddChild(root_0, char_literal14_tree);
					DebugLocation(43, 21);
					IDENT15=(IToken)Match(input,IDENT,Follow._IDENT_in_variable147); 
					IDENT15_tree = (CommonTree)adaptor.Create(IDENT15);
					adaptor.AddChild(root_0, IDENT15_tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(43, 29);
			char_literal16=(IToken)Match(input,33,Follow._33_in_variable151); 
			char_literal16_tree = (CommonTree)adaptor.Create(char_literal16);
			adaptor.AddChild(root_0, char_literal16_tree);
			DebugLocation(43, 33);
			PushFollow(Follow._type_in_variable153);
			type17=type();
			PopFollow();

			adaptor.AddChild(root_0, type17.Tree);
			DebugLocation(43, 38);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:38: ( '=' expression )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==37))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:43:39: '=' expression
				{
				DebugLocation(43, 39);
				char_literal18=(IToken)Match(input,37,Follow._37_in_variable156); 
				char_literal18_tree = (CommonTree)adaptor.Create(char_literal18);
				adaptor.AddChild(root_0, char_literal18_tree);
				DebugLocation(43, 43);
				PushFollow(Follow._expression_in_variable158);
				expression19=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(43, 56);
			char_literal20=(IToken)Match(input,34,Follow._34_in_variable162); 
			char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
			adaptor.AddChild(root_0, char_literal20_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:46:1: type : 'Integer' ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<CommonTree, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal21 = default(IToken);

		CommonTree string_literal21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(46, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:2: ( 'Integer' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:47:4: 'Integer'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(47, 4);
			string_literal21=(IToken)Match(input,41,Follow._41_in_type174); 
			string_literal21_tree = (CommonTree)adaptor.Create(string_literal21);
			adaptor.AddChild(root_0, string_literal21_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:50:1: ifStatement : 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 5);
		TraceIn("ifStatement", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal22 = default(IToken);
		IToken char_literal24 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement25 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elsif26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> else_g27 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endif28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal22_tree = default(CommonTree);
		CommonTree char_literal24_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(50, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:2: ( 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:4: 'if' ^ expression ':' ( statement )* ( elsif )* ( else_g )? endif
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(51, 8);
			string_literal22=(IToken)Match(input,50,Follow._50_in_ifStatement186); 
			string_literal22_tree = (CommonTree)adaptor.Create(string_literal22);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal22_tree, root_0);
			DebugLocation(51, 10);
			PushFollow(Follow._expression_in_ifStatement189);
			expression23=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression23.Tree);
			DebugLocation(51, 21);
			char_literal24=(IToken)Match(input,33,Follow._33_in_ifStatement191); 
			char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
			adaptor.AddChild(root_0, char_literal24_tree);
			DebugLocation(51, 25);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==IDENT||LA4_1==50||LA4_1==54))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:25: statement
					{
					DebugLocation(51, 25);
					PushFollow(Follow._statement_in_ifStatement193);
					statement25=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement25.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(51, 36);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: ( elsif )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==47))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:36: elsif
					{
					DebugLocation(51, 36);
					PushFollow(Follow._elsif_in_ifStatement196);
					elsif26=elsif();
					PopFollow();

					adaptor.AddChild(root_0, elsif26.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(51, 43);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: ( else_g )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==46))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:51:43: else_g
				{
				DebugLocation(51, 43);
				PushFollow(Follow._else_g_in_ifStatement199);
				else_g27=else_g();
				PopFollow();

				adaptor.AddChild(root_0, else_g27.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(51, 51);
			PushFollow(Follow._endif_in_ifStatement202);
			endif28=endif();
			PopFollow();

			adaptor.AddChild(root_0, endif28.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 5);
			LeaveRule("ifStatement", 5);
			LeaveRule_ifStatement();
		}
		DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_elsif();
	partial void LeaveRule_elsif();
	// $ANTLR start "elsif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:53:1: elsif : 'elsif' ^ expression ':' ( statement )+ ;
	[GrammarRule("elsif")]
	private AstParserRuleReturnScope<CommonTree, IToken> elsif()
	{
		EnterRule_elsif();
		EnterRule("elsif", 6);
		TraceIn("elsif", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression30 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement32 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal29_tree = default(CommonTree);
		CommonTree char_literal31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "elsif");
		DebugLocation(53, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:2: ( 'elsif' ^ expression ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:4: 'elsif' ^ expression ':' ( statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(54, 11);
			string_literal29=(IToken)Match(input,47,Follow._47_in_elsif212); 
			string_literal29_tree = (CommonTree)adaptor.Create(string_literal29);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal29_tree, root_0);
			DebugLocation(54, 13);
			PushFollow(Follow._expression_in_elsif215);
			expression30=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression30.Tree);
			DebugLocation(54, 24);
			char_literal31=(IToken)Match(input,33,Follow._33_in_elsif217); 
			char_literal31_tree = (CommonTree)adaptor.Create(char_literal31);
			adaptor.AddChild(root_0, char_literal31_tree);
			DebugLocation(54, 28);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: ( statement )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==IDENT||LA7_1==50||LA7_1==54))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:54:28: statement
					{
					DebugLocation(54, 28);
					PushFollow(Follow._statement_in_elsif219);
					statement32=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement32.Tree);

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elsif", 6);
			LeaveRule("elsif", 6);
			LeaveRule_elsif();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "elsif"); }
		return retval;

	}
	// $ANTLR end "elsif"

	partial void EnterRule_else_g();
	partial void LeaveRule_else_g();
	// $ANTLR start "else_g"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:56:1: else_g : ( 'else' ^ ':' ( statement )+ ) ;
	[GrammarRule("else_g")]
	private AstParserRuleReturnScope<CommonTree, IToken> else_g()
	{
		EnterRule_else_g();
		EnterRule("else_g", 7);
		TraceIn("else_g", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal33_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "else_g");
		DebugLocation(56, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:2: ( ( 'else' ^ ':' ( statement )+ ) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(57, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:4: ( 'else' ^ ':' ( statement )+ )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:5: 'else' ^ ':' ( statement )+
			{
			DebugLocation(57, 11);
			string_literal33=(IToken)Match(input,46,Follow._46_in_else_g231); 
			string_literal33_tree = (CommonTree)adaptor.Create(string_literal33);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal33_tree, root_0);
			DebugLocation(57, 13);
			char_literal34=(IToken)Match(input,33,Follow._33_in_else_g234); 
			char_literal34_tree = (CommonTree)adaptor.Create(char_literal34);
			adaptor.AddChild(root_0, char_literal34_tree);
			DebugLocation(57, 17);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: ( statement )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==IDENT||LA8_1==50||LA8_1==54))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:57:17: statement
					{
					DebugLocation(57, 17);
					PushFollow(Follow._statement_in_else_g236);
					statement35=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement35.Tree);

					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("else_g", 7);
			LeaveRule("else_g", 7);
			LeaveRule_else_g();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "else_g"); }
		return retval;

	}
	// $ANTLR end "else_g"

	partial void EnterRule_endif();
	partial void LeaveRule_endif();
	// $ANTLR start "endif"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:59:1: endif : 'endif' ';' ;
	[GrammarRule("endif")]
	private AstParserRuleReturnScope<CommonTree, IToken> endif()
	{
		EnterRule_endif();
		EnterRule("endif", 8);
		TraceIn("endif", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal36 = default(IToken);
		IToken char_literal37 = default(IToken);

		CommonTree string_literal36_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "endif");
		DebugLocation(59, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:2: ( 'endif' ';' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:60:4: 'endif' ';'
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(60, 4);
			string_literal36=(IToken)Match(input,49,Follow._49_in_endif248); 
			string_literal36_tree = (CommonTree)adaptor.Create(string_literal36);
			adaptor.AddChild(root_0, string_literal36_tree);
			DebugLocation(60, 12);
			char_literal37=(IToken)Match(input,34,Follow._34_in_endif250); 
			char_literal37_tree = (CommonTree)adaptor.Create(char_literal37);
			adaptor.AddChild(root_0, char_literal37_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endif", 8);
			LeaveRule("endif", 8);
			LeaveRule_endif();
		}
		DebugLocation(61, 1);
		} finally { DebugExitRule(GrammarFileName, "endif"); }
		return retval;

	}
	// $ANTLR end "endif"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:63:1: whileStatement : 'while' ^ whileBody ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 9);
		TraceIn("whileStatement", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal38 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> whileBody39 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(63, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:2: ( 'while' ^ whileBody )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:64:4: 'while' ^ whileBody
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(64, 11);
			string_literal38=(IToken)Match(input,54,Follow._54_in_whileStatement262); 
			string_literal38_tree = (CommonTree)adaptor.Create(string_literal38);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal38_tree, root_0);
			DebugLocation(64, 13);
			PushFollow(Follow._whileBody_in_whileStatement265);
			whileBody39=whileBody();
			PopFollow();

			adaptor.AddChild(root_0, whileBody39.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 9);
			LeaveRule("whileStatement", 9);
			LeaveRule_whileStatement();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_whileBody();
	partial void LeaveRule_whileBody();
	// $ANTLR start "whileBody"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:69:1: whileBody : expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' ;
	[GrammarRule("whileBody")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileBody()
	{
		EnterRule_whileBody();
		EnterRule("whileBody", 10);
		TraceIn("whileBody", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal41 = default(IToken);
		IToken string_literal43 = default(IToken);
		IToken string_literal44 = default(IToken);
		IToken char_literal45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement42 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal41_tree = default(CommonTree);
		CommonTree string_literal43_tree = default(CommonTree);
		CommonTree string_literal44_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_33=new RewriteRuleITokenStream(adaptor,"token 33");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileBody");
		DebugLocation(69, 77);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:2: ( expression ':' ( statement )* 'end' 'while' ';' -> expression ( statement )* 'end' )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:4: expression ':' ( statement )* 'end' 'while' ';'
			{
			DebugLocation(70, 4);
			PushFollow(Follow._expression_in_whileBody278);
			expression40=expression();
			PopFollow();

			stream_expression.Add(expression40.Tree);
			DebugLocation(70, 15);
			char_literal41=(IToken)Match(input,33,Follow._33_in_whileBody280);  
			stream_33.Add(char_literal41);

			DebugLocation(70, 19);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: ( statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==IDENT||LA9_1==50||LA9_1==54))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:19: statement
					{
					DebugLocation(70, 19);
					PushFollow(Follow._statement_in_whileBody282);
					statement42=statement();
					PopFollow();

					stream_statement.Add(statement42.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(70, 30);
			string_literal43=(IToken)Match(input,48,Follow._48_in_whileBody285);  
			stream_48.Add(string_literal43);

			DebugLocation(70, 36);
			string_literal44=(IToken)Match(input,54,Follow._54_in_whileBody287);  
			stream_54.Add(string_literal44);

			DebugLocation(70, 44);
			char_literal45=(IToken)Match(input,34,Follow._34_in_whileBody289);  
			stream_34.Add(char_literal45);



			{
			// AST REWRITE
			// elements: 48, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 70:48: -> expression ( statement )* 'end'
			{
				DebugLocation(70, 51);
				adaptor.AddChild(root_0, stream_expression.NextTree());
				DebugLocation(70, 62);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:70:62: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(70, 62);
					adaptor.AddChild(root_0, stream_statement.NextTree());

				}
				stream_statement.Reset();
				DebugLocation(70, 73);
				adaptor.AddChild(root_0, stream_48.NextNode());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileBody", 10);
			LeaveRule("whileBody", 10);
			LeaveRule_whileBody();
		}
		DebugLocation(70, 77);
		} finally { DebugExitRule(GrammarFileName, "whileBody"); }
		return retval;

	}
	// $ANTLR end "whileBody"

	partial void EnterRule_funCallStatement();
	partial void LeaveRule_funCallStatement();
	// $ANTLR start "funCallStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:73:1: funCallStatement : (name= IDENT '(' a= expression ( ',' b+= expression )* ')' -> ^( FUNC $name $a ( $b)* ) | emptyArgsFun );
	[GrammarRule("funCallStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> funCallStatement()
	{
		EnterRule_funCallStatement();
		EnterRule("funCallStatement", 11);
		TraceIn("funCallStatement", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken name = default(IToken);
		IToken char_literal46 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken char_literal48 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> emptyArgsFun49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree name_tree = default(CommonTree);
		CommonTree char_literal46_tree = default(CommonTree);
		CommonTree char_literal47_tree = default(CommonTree);
		CommonTree char_literal48_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_25=new RewriteRuleITokenStream(adaptor,"token 25");
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "funCallStatement");
		DebugLocation(73, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:2: (name= IDENT '(' a= expression ( ',' b+= expression )* ')' -> ^( FUNC $name $a ( $b)* ) | emptyArgsFun )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==IDENT))
			{
				int LA11_2 = input.LA(2);

				if ((LA11_2==25))
				{
					int LA11_3 = input.LA(3);

					if ((LA11_3==26))
					{
						alt11 = 2;
					}
					else if ((LA11_3==BOOL||LA11_3==FLOAT||(LA11_3>=IDENT && LA11_3<=INTEGER)||LA11_3==STRING||LA11_3==25||LA11_3==28||LA11_3==30||LA11_3==42||LA11_3==52))
					{
						alt11 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:4: name= IDENT '(' a= expression ( ',' b+= expression )* ')'
				{
				DebugLocation(74, 9);
				name=(IToken)Match(input,IDENT,Follow._IDENT_in_funCallStatement313);  
				stream_IDENT.Add(name);

				DebugLocation(74, 17);
				char_literal46=(IToken)Match(input,25,Follow._25_in_funCallStatement315);  
				stream_25.Add(char_literal46);

				DebugLocation(74, 23);
				PushFollow(Follow._expression_in_funCallStatement321);
				a=expression();
				PopFollow();

				stream_expression.Add(a.Tree);
				DebugLocation(74, 36);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:36: ( ',' b+= expression )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1==29))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:37: ',' b+= expression
						{
						DebugLocation(74, 37);
						char_literal47=(IToken)Match(input,29,Follow._29_in_funCallStatement324);  
						stream_29.Add(char_literal47);

						DebugLocation(74, 43);
						PushFollow(Follow._expression_in_funCallStatement330);
						b=expression();
						PopFollow();

						stream_expression.Add(b.Tree);
						if (list_b==null) list_b=new List<CommonTree>();
						list_b.Add(b.Tree);


						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(74, 59);
				char_literal48=(IToken)Match(input,26,Follow._26_in_funCallStatement334);  
				stream_26.Add(char_literal48);



				{
				// AST REWRITE
				// elements: b, name, a
				// token labels: name
				// rule labels: retval, a
				// token list labels: 
				// rule list labels: b
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
				root_0 = (CommonTree)adaptor.Nil();
				// 74:64: -> ^( FUNC $name $a ( $b)* )
				{
					DebugLocation(74, 67);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:67: ^( FUNC $name $a ( $b)* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(74, 69);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC, "FUNC"), root_1);

					DebugLocation(74, 75);
					adaptor.AddChild(root_1, stream_name.NextNode());
					DebugLocation(74, 81);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(74, 84);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:74:84: ( $b)*
					while ( stream_b.HasNext )
					{
						DebugLocation(74, 84);
						adaptor.AddChild(root_1, stream_b.NextTree());

					}
					stream_b.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:75:4: emptyArgsFun
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(75, 4);
				PushFollow(Follow._emptyArgsFun_in_funCallStatement356);
				emptyArgsFun49=emptyArgsFun();
				PopFollow();

				adaptor.AddChild(root_0, emptyArgsFun49.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funCallStatement", 11);
			LeaveRule("funCallStatement", 11);
			LeaveRule_funCallStatement();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "funCallStatement"); }
		return retval;

	}
	// $ANTLR end "funCallStatement"

	partial void EnterRule_emptyArgsFun();
	partial void LeaveRule_emptyArgsFun();
	// $ANTLR start "emptyArgsFun"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:83:1: emptyArgsFun : name= IDENT '(' ')' -> ^( FUNC $name) ;
	[GrammarRule("emptyArgsFun")]
	private AstParserRuleReturnScope<CommonTree, IToken> emptyArgsFun()
	{
		EnterRule_emptyArgsFun();
		EnterRule("emptyArgsFun", 12);
		TraceIn("emptyArgsFun", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken name = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal51 = default(IToken);

		CommonTree name_tree = default(CommonTree);
		CommonTree char_literal50_tree = default(CommonTree);
		CommonTree char_literal51_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_25=new RewriteRuleITokenStream(adaptor,"token 25");
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		try { DebugEnterRule(GrammarFileName, "emptyArgsFun");
		DebugLocation(83, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:2: (name= IDENT '(' ')' -> ^( FUNC $name) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:4: name= IDENT '(' ')'
			{
			DebugLocation(84, 9);
			name=(IToken)Match(input,IDENT,Follow._IDENT_in_emptyArgsFun386);  
			stream_IDENT.Add(name);

			DebugLocation(84, 17);
			char_literal50=(IToken)Match(input,25,Follow._25_in_emptyArgsFun388);  
			stream_25.Add(char_literal50);

			DebugLocation(84, 21);
			char_literal51=(IToken)Match(input,26,Follow._26_in_emptyArgsFun390);  
			stream_26.Add(char_literal51);



			{
			// AST REWRITE
			// elements: name
			// token labels: name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 84:26: -> ^( FUNC $name)
			{
				DebugLocation(84, 29);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:84:29: ^( FUNC $name)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(84, 31);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(84, 37);
				adaptor.AddChild(root_1, stream_name.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyArgsFun", 12);
			LeaveRule("emptyArgsFun", 12);
			LeaveRule_emptyArgsFun();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyArgsFun"); }
		return retval;

	}
	// $ANTLR end "emptyArgsFun"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:87:1: statement : ( assignmentStatement | whileStatement | ifStatement | funCallStatement ';' | accessorStatement ';' );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 13);
		TraceIn("statement", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal56 = default(IToken);
		IToken char_literal58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement53 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> funCallStatement55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessorStatement57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal56_tree = default(CommonTree);
		CommonTree char_literal58_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(87, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:88:2: ( assignmentStatement | whileStatement | ifStatement | funCallStatement ';' | accessorStatement ';' )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				switch (input.LA(2))
				{
				case 37:
				case 42:
					{
					alt12 = 1;
					}
					break;
				case 25:
					{
					alt12 = 4;
					}
					break;
				case 31:
					{
					alt12 = 5;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case 54:
				{
				alt12 = 2;
				}
				break;
			case 50:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:88:4: assignmentStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._assignmentStatement_in_statement412);
				assignmentStatement52=assignmentStatement();
				PopFollow();

				adaptor.AddChild(root_0, assignmentStatement52.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:89:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._whileStatement_in_statement417);
				whileStatement53=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement53.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:90:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._ifStatement_in_statement422);
				ifStatement54=ifStatement();
				PopFollow();

				adaptor.AddChild(root_0, ifStatement54.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:91:4: funCallStatement ';'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._funCallStatement_in_statement427);
				funCallStatement55=funCallStatement();
				PopFollow();

				adaptor.AddChild(root_0, funCallStatement55.Tree);
				DebugLocation(91, 21);
				char_literal56=(IToken)Match(input,34,Follow._34_in_statement429); 
				char_literal56_tree = (CommonTree)adaptor.Create(char_literal56);
				adaptor.AddChild(root_0, char_literal56_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:92:4: accessorStatement ';'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(92, 4);
				PushFollow(Follow._accessorStatement_in_statement434);
				accessorStatement57=accessorStatement();
				PopFollow();

				adaptor.AddChild(root_0, accessorStatement57.Tree);
				DebugLocation(92, 22);
				char_literal58=(IToken)Match(input,34,Follow._34_in_statement436); 
				char_literal58_tree = (CommonTree)adaptor.Create(char_literal58);
				adaptor.AddChild(root_0, char_literal58_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 13);
			LeaveRule("statement", 13);
			LeaveRule_statement();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_assignmentStatement();
	partial void LeaveRule_assignmentStatement();
	// $ANTLR start "assignmentStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:95:1: assignmentStatement : ( IDENT '=' ^ expression ';' | IDENT '=' ^ accessorStatement ';' | accessor '=' ^ expression ';' );
	[GrammarRule("assignmentStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentStatement()
	{
		EnterRule_assignmentStatement();
		EnterRule("assignmentStatement", 14);
		TraceIn("assignmentStatement", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT59 = default(IToken);
		IToken char_literal60 = default(IToken);
		IToken char_literal62 = default(IToken);
		IToken IDENT63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken char_literal66 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken char_literal70 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression61 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessorStatement65 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessor67 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT59_tree = default(CommonTree);
		CommonTree char_literal60_tree = default(CommonTree);
		CommonTree char_literal62_tree = default(CommonTree);
		CommonTree IDENT63_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		CommonTree char_literal66_tree = default(CommonTree);
		CommonTree char_literal68_tree = default(CommonTree);
		CommonTree char_literal70_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentStatement");
		DebugLocation(95, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:2: ( IDENT '=' ^ expression ';' | IDENT '=' ^ accessorStatement ';' | accessor '=' ^ expression ';' )
			int alt13=3;
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==IDENT))
			{
				int LA13_2 = input.LA(2);

				if ((LA13_2==37))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==BOOL||LA13_3==FLOAT||LA13_3==INTEGER||LA13_3==STRING||LA13_3==25||LA13_3==28||LA13_3==30||LA13_3==42||LA13_3==52))
					{
						alt13 = 1;
					}
					else if ((LA13_3==IDENT))
					{
						int LA13_4 = input.LA(4);

						if (((LA13_4>=23 && LA13_4<=25)||(LA13_4>=27 && LA13_4<=28)||LA13_4==30||LA13_4==32||(LA13_4>=34 && LA13_4<=36)||(LA13_4>=38 && LA13_4<=40)||LA13_4==42||LA13_4==51||LA13_4==55))
						{
							alt13 = 1;
						}
						else if ((LA13_4==31))
						{
							alt13 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 13, 5, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA13_2==42))
				{
					alt13 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:96:4: IDENT '=' ^ expression ';'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(96, 4);
				IDENT59=(IToken)Match(input,IDENT,Follow._IDENT_in_assignmentStatement447); 
				IDENT59_tree = (CommonTree)adaptor.Create(IDENT59);
				adaptor.AddChild(root_0, IDENT59_tree);
				DebugLocation(96, 13);
				char_literal60=(IToken)Match(input,37,Follow._37_in_assignmentStatement449); 
				char_literal60_tree = (CommonTree)adaptor.Create(char_literal60);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal60_tree, root_0);
				DebugLocation(96, 15);
				PushFollow(Follow._expression_in_assignmentStatement452);
				expression61=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression61.Tree);
				DebugLocation(96, 26);
				char_literal62=(IToken)Match(input,34,Follow._34_in_assignmentStatement454); 
				char_literal62_tree = (CommonTree)adaptor.Create(char_literal62);
				adaptor.AddChild(root_0, char_literal62_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:99:4: IDENT '=' ^ accessorStatement ';'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(99, 4);
				IDENT63=(IToken)Match(input,IDENT,Follow._IDENT_in_assignmentStatement461); 
				IDENT63_tree = (CommonTree)adaptor.Create(IDENT63);
				adaptor.AddChild(root_0, IDENT63_tree);
				DebugLocation(99, 13);
				char_literal64=(IToken)Match(input,37,Follow._37_in_assignmentStatement463); 
				char_literal64_tree = (CommonTree)adaptor.Create(char_literal64);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal64_tree, root_0);
				DebugLocation(99, 15);
				PushFollow(Follow._accessorStatement_in_assignmentStatement466);
				accessorStatement65=accessorStatement();
				PopFollow();

				adaptor.AddChild(root_0, accessorStatement65.Tree);
				DebugLocation(99, 33);
				char_literal66=(IToken)Match(input,34,Follow._34_in_assignmentStatement468); 
				char_literal66_tree = (CommonTree)adaptor.Create(char_literal66);
				adaptor.AddChild(root_0, char_literal66_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:100:5: accessor '=' ^ expression ';'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(100, 5);
				PushFollow(Follow._accessor_in_assignmentStatement474);
				accessor67=accessor();
				PopFollow();

				adaptor.AddChild(root_0, accessor67.Tree);
				DebugLocation(100, 17);
				char_literal68=(IToken)Match(input,37,Follow._37_in_assignmentStatement476); 
				char_literal68_tree = (CommonTree)adaptor.Create(char_literal68);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal68_tree, root_0);
				DebugLocation(100, 19);
				PushFollow(Follow._expression_in_assignmentStatement479);
				expression69=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression69.Tree);
				DebugLocation(100, 30);
				char_literal70=(IToken)Match(input,34,Follow._34_in_assignmentStatement481); 
				char_literal70_tree = (CommonTree)adaptor.Create(char_literal70);
				adaptor.AddChild(root_0, char_literal70_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentStatement", 14);
			LeaveRule("assignmentStatement", 14);
			LeaveRule_assignmentStatement();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentStatement"); }
		return retval;

	}
	// $ANTLR end "assignmentStatement"

	partial void EnterRule_accessor();
	partial void LeaveRule_accessor();
	// $ANTLR start "accessor"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:105:1: accessor : a= IDENT ( '[' b+= expression ']' )+ -> ^( ACCESS $a ( $b)+ ) ;
	[GrammarRule("accessor")]
	private AstParserRuleReturnScope<CommonTree, IToken> accessor()
	{
		EnterRule_accessor();
		EnterRule("accessor", 15);
		TraceIn("accessor", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken a = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken char_literal72 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree a_tree = default(CommonTree);
		CommonTree char_literal71_tree = default(CommonTree);
		CommonTree char_literal72_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "accessor");
		DebugLocation(105, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:106:2: (a= IDENT ( '[' b+= expression ']' )+ -> ^( ACCESS $a ( $b)+ ) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:106:4: a= IDENT ( '[' b+= expression ']' )+
			{
			DebugLocation(106, 6);
			a=(IToken)Match(input,IDENT,Follow._IDENT_in_accessor498);  
			stream_IDENT.Add(a);

			DebugLocation(106, 14);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:106:14: ( '[' b+= expression ']' )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==42))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:106:15: '[' b+= expression ']'
					{
					DebugLocation(106, 15);
					char_literal71=(IToken)Match(input,42,Follow._42_in_accessor501);  
					stream_42.Add(char_literal71);

					DebugLocation(106, 21);
					PushFollow(Follow._expression_in_accessor507);
					b=expression();
					PopFollow();

					stream_expression.Add(b.Tree);
					if (list_b==null) list_b=new List<CommonTree>();
					list_b.Add(b.Tree);

					DebugLocation(106, 35);
					char_literal72=(IToken)Match(input,43,Follow._43_in_accessor509);  
					stream_43.Add(char_literal72);


					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: b, a
			// token labels: a
			// rule labels: retval
			// token list labels: 
			// rule list labels: b
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_a=new RewriteRuleITokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
			root_0 = (CommonTree)adaptor.Nil();
			// 106:41: -> ^( ACCESS $a ( $b)+ )
			{
				DebugLocation(106, 44);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:106:44: ^( ACCESS $a ( $b)+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(106, 46);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ACCESS, "ACCESS"), root_1);

				DebugLocation(106, 54);
				adaptor.AddChild(root_1, stream_a.NextNode());
				DebugLocation(106, 57);
				if (!(stream_b.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_b.HasNext )
				{
					DebugLocation(106, 57);
					adaptor.AddChild(root_1, stream_b.NextTree());

				}
				stream_b.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessor", 15);
			LeaveRule("accessor", 15);
			LeaveRule_accessor();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "accessor"); }
		return retval;

	}
	// $ANTLR end "accessor"

	partial void EnterRule_accessorStatement();
	partial void LeaveRule_accessorStatement();
	// $ANTLR start "accessorStatement"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:113:1: accessorStatement : a= IDENT ( '.' b+= funCallStatement )+ -> ^( FIELD_ACCESS $a ( $b)+ ) ;
	[GrammarRule("accessorStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> accessorStatement()
	{
		EnterRule_accessorStatement();
		EnterRule("accessorStatement", 16);
		TraceIn("accessorStatement", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken a = default(IToken);
		IToken char_literal73 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree a_tree = default(CommonTree);
		CommonTree char_literal73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleSubtreeStream stream_funCallStatement=new RewriteRuleSubtreeStream(adaptor,"rule funCallStatement");
		try { DebugEnterRule(GrammarFileName, "accessorStatement");
		DebugLocation(113, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:2: (a= IDENT ( '.' b+= funCallStatement )+ -> ^( FIELD_ACCESS $a ( $b)+ ) )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:4: a= IDENT ( '.' b+= funCallStatement )+
			{
			DebugLocation(114, 5);
			a=(IToken)Match(input,IDENT,Follow._IDENT_in_accessorStatement549);  
			stream_IDENT.Add(a);

			DebugLocation(114, 12);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:12: ( '.' b+= funCallStatement )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==31))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:13: '.' b+= funCallStatement
					{
					DebugLocation(114, 13);
					char_literal73=(IToken)Match(input,31,Follow._31_in_accessorStatement552);  
					stream_31.Add(char_literal73);

					DebugLocation(114, 18);
					PushFollow(Follow._funCallStatement_in_accessorStatement556);
					b=funCallStatement();
					PopFollow();

					stream_funCallStatement.Add(b.Tree);
					if (list_b==null) list_b=new List<CommonTree>();
					list_b.Add(b.Tree);


					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }



			{
			// AST REWRITE
			// elements: b, a
			// token labels: a
			// rule labels: retval
			// token list labels: 
			// rule list labels: b
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_a=new RewriteRuleITokenStream(adaptor,"token a",a);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
			root_0 = (CommonTree)adaptor.Nil();
			// 114:40: -> ^( FIELD_ACCESS $a ( $b)+ )
			{
				DebugLocation(114, 43);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:114:43: ^( FIELD_ACCESS $a ( $b)+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(114, 45);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FIELD_ACCESS, "FIELD_ACCESS"), root_1);

				DebugLocation(114, 59);
				adaptor.AddChild(root_1, stream_a.NextNode());
				DebugLocation(114, 62);
				if (!(stream_b.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_b.HasNext )
				{
					DebugLocation(114, 62);
					adaptor.AddChild(root_1, stream_b.NextTree());

				}
				stream_b.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessorStatement", 16);
			LeaveRule("accessorStatement", 16);
			LeaveRule_accessorStatement();
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "accessorStatement"); }
		return retval;

	}
	// $ANTLR end "accessorStatement"

	partial void EnterRule_array();
	partial void LeaveRule_array();
	// $ANTLR start "array"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:121:1: array : ( '[' a= expression ( ',' b+= expression )* ']' -> ^( ARRAY $a ( $b)* ) | '[' ']' -> ^( ARRAY ) );
	[GrammarRule("array")]
	private AstParserRuleReturnScope<CommonTree, IToken> array()
	{
		EnterRule_array();
		EnterRule("array", 17);
		TraceIn("array", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken char_literal76 = default(IToken);
		IToken char_literal77 = default(IToken);
		IToken char_literal78 = default(IToken);
		List<CommonTree> list_b = null;
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree char_literal74_tree = default(CommonTree);
		CommonTree char_literal75_tree = default(CommonTree);
		CommonTree char_literal76_tree = default(CommonTree);
		CommonTree char_literal77_tree = default(CommonTree);
		CommonTree char_literal78_tree = default(CommonTree);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "array");
		DebugLocation(121, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:2: ( '[' a= expression ( ',' b+= expression )* ']' -> ^( ARRAY $a ( $b)* ) | '[' ']' -> ^( ARRAY ) )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==42))
			{
				int LA17_2 = input.LA(2);

				if ((LA17_2==43))
				{
					alt17 = 2;
				}
				else if ((LA17_2==BOOL||LA17_2==FLOAT||(LA17_2>=IDENT && LA17_2<=INTEGER)||LA17_2==STRING||LA17_2==25||LA17_2==28||LA17_2==30||LA17_2==42||LA17_2==52))
				{
					alt17 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:122:4: '[' a= expression ( ',' b+= expression )* ']'
				{
				DebugLocation(122, 4);
				char_literal74=(IToken)Match(input,42,Follow._42_in_array595);  
				stream_42.Add(char_literal74);

				DebugLocation(122, 9);
				PushFollow(Follow._expression_in_array600);
				a=expression();
				PopFollow();

				stream_expression.Add(a.Tree);
				DebugLocation(123, 2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:123:2: ( ',' b+= expression )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if ((LA16_1==29))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:123:3: ',' b+= expression
						{
						DebugLocation(123, 3);
						char_literal75=(IToken)Match(input,29,Follow._29_in_array604);  
						stream_29.Add(char_literal75);

						DebugLocation(123, 9);
						PushFollow(Follow._expression_in_array610);
						b=expression();
						PopFollow();

						stream_expression.Add(b.Tree);
						if (list_b==null) list_b=new List<CommonTree>();
						list_b.Add(b.Tree);


						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }

				DebugLocation(123, 24);
				char_literal76=(IToken)Match(input,43,Follow._43_in_array613);  
				stream_43.Add(char_literal76);



				{
				// AST REWRITE
				// elements: b, a
				// token labels: 
				// rule labels: retval, a
				// token list labels: 
				// rule list labels: b
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"token b",list_b);
				root_0 = (CommonTree)adaptor.Nil();
				// 123:28: -> ^( ARRAY $a ( $b)* )
				{
					DebugLocation(123, 31);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:123:31: ^( ARRAY $a ( $b)* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(123, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY, "ARRAY"), root_1);

					DebugLocation(123, 40);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(123, 43);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:123:43: ( $b)*
					while ( stream_b.HasNext )
					{
						DebugLocation(123, 43);
						adaptor.AddChild(root_1, stream_b.NextTree());

					}
					stream_b.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:124:4: '[' ']'
				{
				DebugLocation(124, 4);
				char_literal77=(IToken)Match(input,42,Follow._42_in_array631);  
				stream_42.Add(char_literal77);

				DebugLocation(124, 7);
				char_literal78=(IToken)Match(input,43,Follow._43_in_array632);  
				stream_43.Add(char_literal78);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 124:11: -> ^( ARRAY )
				{
					DebugLocation(124, 14);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:124:14: ^( ARRAY )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(124, 16);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY, "ARRAY"), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array", 17);
			LeaveRule("array", 17);
			LeaveRule_array();
		}
		DebugLocation(125, 1);
		} finally { DebugExitRule(GrammarFileName, "array"); }
		return retval;

	}
	// $ANTLR end "array"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:131:1: term : ( IDENT | '(' expression ')' -> expression | INTEGER | STRING | BOOL | FLOAT | array | accessor | funCallStatement );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 18);
		TraceIn("term", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT79 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken char_literal82 = default(IToken);
		IToken INTEGER83 = default(IToken);
		IToken STRING84 = default(IToken);
		IToken BOOL85 = default(IToken);
		IToken FLOAT86 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression81 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> array87 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessor88 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> funCallStatement89 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT79_tree = default(CommonTree);
		CommonTree char_literal80_tree = default(CommonTree);
		CommonTree char_literal82_tree = default(CommonTree);
		CommonTree INTEGER83_tree = default(CommonTree);
		CommonTree STRING84_tree = default(CommonTree);
		CommonTree BOOL85_tree = default(CommonTree);
		CommonTree FLOAT86_tree = default(CommonTree);
		RewriteRuleITokenStream stream_25=new RewriteRuleITokenStream(adaptor,"token 25");
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(131, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:132:2: ( IDENT | '(' expression ')' -> expression | INTEGER | STRING | BOOL | FLOAT | array | accessor | funCallStatement )
			int alt18=9;
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				switch (input.LA(2))
				{
				case 25:
					{
					alt18 = 9;
					}
					break;
				case 23:
				case 24:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
				case 38:
				case 39:
				case 40:
				case 43:
				case 51:
				case 55:
					{
					alt18 = 1;
					}
					break;
				case 42:
					{
					alt18 = 8;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 18, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case 25:
				{
				alt18 = 2;
				}
				break;
			case INTEGER:
				{
				alt18 = 3;
				}
				break;
			case STRING:
				{
				alt18 = 4;
				}
				break;
			case BOOL:
				{
				alt18 = 5;
				}
				break;
			case FLOAT:
				{
				alt18 = 6;
				}
				break;
			case 42:
				{
				alt18 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:132:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(132, 4);
				IDENT79=(IToken)Match(input,IDENT,Follow._IDENT_in_term661); 
				IDENT79_tree = (CommonTree)adaptor.Create(IDENT79);
				adaptor.AddChild(root_0, IDENT79_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:133:4: '(' expression ')'
				{
				DebugLocation(133, 4);
				char_literal80=(IToken)Match(input,25,Follow._25_in_term666);  
				stream_25.Add(char_literal80);

				DebugLocation(133, 8);
				PushFollow(Follow._expression_in_term668);
				expression81=expression();
				PopFollow();

				stream_expression.Add(expression81.Tree);
				DebugLocation(133, 19);
				char_literal82=(IToken)Match(input,26,Follow._26_in_term670);  
				stream_26.Add(char_literal82);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 133:23: -> expression
				{
					DebugLocation(133, 26);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:134:4: INTEGER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(134, 4);
				INTEGER83=(IToken)Match(input,INTEGER,Follow._INTEGER_in_term679); 
				INTEGER83_tree = (CommonTree)adaptor.Create(INTEGER83);
				adaptor.AddChild(root_0, INTEGER83_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:135:5: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(135, 5);
				STRING84=(IToken)Match(input,STRING,Follow._STRING_in_term685); 
				STRING84_tree = (CommonTree)adaptor.Create(STRING84);
				adaptor.AddChild(root_0, STRING84_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:136:4: BOOL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(136, 4);
				BOOL85=(IToken)Match(input,BOOL,Follow._BOOL_in_term690); 
				BOOL85_tree = (CommonTree)adaptor.Create(BOOL85);
				adaptor.AddChild(root_0, BOOL85_tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:137:4: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(137, 4);
				FLOAT86=(IToken)Match(input,FLOAT,Follow._FLOAT_in_term695); 
				FLOAT86_tree = (CommonTree)adaptor.Create(FLOAT86);
				adaptor.AddChild(root_0, FLOAT86_tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:138:4: array
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(138, 4);
				PushFollow(Follow._array_in_term700);
				array87=array();
				PopFollow();

				adaptor.AddChild(root_0, array87.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:139:4: accessor
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(139, 4);
				PushFollow(Follow._accessor_in_term705);
				accessor88=accessor();
				PopFollow();

				adaptor.AddChild(root_0, accessor88.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\Eclipse\\aegiscript_live\\aegiscript.g:140:4: funCallStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(140, 4);
				PushFollow(Follow._funCallStatement_in_term710);
				funCallStatement89=funCallStatement();
				PopFollow();

				adaptor.AddChild(root_0, funCallStatement89.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 18);
			LeaveRule("term", 18);
			LeaveRule_term();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_negation();
	partial void LeaveRule_negation();
	// $ANTLR start "negation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:143:1: negation : ( 'not' ^)* term ;
	[GrammarRule("negation")]
	private AstParserRuleReturnScope<CommonTree, IToken> negation()
	{
		EnterRule_negation();
		EnterRule("negation", 19);
		TraceIn("negation", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal90 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> term91 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal90_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "negation");
		DebugLocation(143, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:144:2: ( ( 'not' ^)* term )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:144:4: ( 'not' ^)* term
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(144, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:144:9: ( 'not' ^)*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==52))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:144:9: 'not' ^
					{
					DebugLocation(144, 9);
					string_literal90=(IToken)Match(input,52,Follow._52_in_negation722); 
					string_literal90_tree = (CommonTree)adaptor.Create(string_literal90);
					root_0 = (CommonTree)adaptor.BecomeRoot(string_literal90_tree, root_0);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(144, 12);
			PushFollow(Follow._term_in_negation726);
			term91=term();
			PopFollow();

			adaptor.AddChild(root_0, term91.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negation", 19);
			LeaveRule("negation", 19);
			LeaveRule_negation();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "negation"); }
		return retval;

	}
	// $ANTLR end "negation"

	partial void EnterRule_unary();
	partial void LeaveRule_unary();
	// $ANTLR start "unary"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:147:1: unary : ( '+' ^| '-' ^)* negation ;
	[GrammarRule("unary")]
	private AstParserRuleReturnScope<CommonTree, IToken> unary()
	{
		EnterRule_unary();
		EnterRule("unary", 20);
		TraceIn("unary", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal92 = default(IToken);
		IToken char_literal93 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> negation94 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal92_tree = default(CommonTree);
		CommonTree char_literal93_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary");
		DebugLocation(147, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:148:2: ( ( '+' ^| '-' ^)* negation )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:148:4: ( '+' ^| '-' ^)* negation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(148, 4);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:148:4: ( '+' ^| '-' ^)*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=3;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==28))
				{
					alt20 = 1;
				}
				else if ((LA20_1==30))
				{
					alt20 = 2;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:148:5: '+' ^
					{
					DebugLocation(148, 8);
					char_literal92=(IToken)Match(input,28,Follow._28_in_unary740); 
					char_literal92_tree = (CommonTree)adaptor.Create(char_literal92);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal92_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:148:12: '-' ^
					{
					DebugLocation(148, 15);
					char_literal93=(IToken)Match(input,30,Follow._30_in_unary745); 
					char_literal93_tree = (CommonTree)adaptor.Create(char_literal93);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal93_tree, root_0);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(148, 19);
			PushFollow(Follow._negation_in_unary750);
			negation94=negation();
			PopFollow();

			adaptor.AddChild(root_0, negation94.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary", 20);
			LeaveRule("unary", 20);
			LeaveRule_unary();
		}
		DebugLocation(149, 1);
		} finally { DebugExitRule(GrammarFileName, "unary"); }
		return retval;

	}
	// $ANTLR end "unary"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:151:1: mult : unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* ;
	[GrammarRule("mult")]
	private AstParserRuleReturnScope<CommonTree, IToken> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 21);
		TraceIn("mult", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal96 = default(IToken);
		IToken char_literal97 = default(IToken);
		IToken string_literal98 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unary95 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unary99 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal96_tree = default(CommonTree);
		CommonTree char_literal97_tree = default(CommonTree);
		CommonTree string_literal98_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(151, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:2: ( unary ( ( '*' ^| '/' ^| 'mod' ^) unary )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:4: unary ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(152, 4);
			PushFollow(Follow._unary_in_mult761);
			unary95=unary();
			PopFollow();

			adaptor.AddChild(root_0, unary95.Tree);
			DebugLocation(152, 10);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:10: ( ( '*' ^| '/' ^| 'mod' ^) unary )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==27||LA22_1==32||LA22_1==51))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:11: ( '*' ^| '/' ^| 'mod' ^) unary
					{
					DebugLocation(152, 11);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:11: ( '*' ^| '/' ^| 'mod' ^)
					int alt21=3;
					try { DebugEnterSubRule(21);
					try { DebugEnterDecision(21, false);
					switch (input.LA(1))
					{
					case 27:
						{
						alt21 = 1;
						}
						break;
					case 32:
						{
						alt21 = 2;
						}
						break;
					case 51:
						{
						alt21 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:12: '*' ^
						{
						DebugLocation(152, 15);
						char_literal96=(IToken)Match(input,27,Follow._27_in_mult765); 
						char_literal96_tree = (CommonTree)adaptor.Create(char_literal96);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal96_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:19: '/' ^
						{
						DebugLocation(152, 22);
						char_literal97=(IToken)Match(input,32,Follow._32_in_mult770); 
						char_literal97_tree = (CommonTree)adaptor.Create(char_literal97);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal97_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:152:26: 'mod' ^
						{
						DebugLocation(152, 31);
						string_literal98=(IToken)Match(input,51,Follow._51_in_mult775); 
						string_literal98_tree = (CommonTree)adaptor.Create(string_literal98);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal98_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(21); }

					DebugLocation(152, 34);
					PushFollow(Follow._unary_in_mult779);
					unary99=unary();
					PopFollow();

					adaptor.AddChild(root_0, unary99.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mult", 21);
			LeaveRule("mult", 21);
			LeaveRule_mult();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_add();
	partial void LeaveRule_add();
	// $ANTLR start "add"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:155:1: add : mult ( ( '+' ^| '-' ^) mult )* ;
	[GrammarRule("add")]
	private AstParserRuleReturnScope<CommonTree, IToken> add()
	{
		EnterRule_add();
		EnterRule("add", 22);
		TraceIn("add", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal101 = default(IToken);
		IToken char_literal102 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mult100 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mult103 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal101_tree = default(CommonTree);
		CommonTree char_literal102_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(155, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:2: ( mult ( ( '+' ^| '-' ^) mult )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:4: mult ( ( '+' ^| '-' ^) mult )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(156, 4);
			PushFollow(Follow._mult_in_add793);
			mult100=mult();
			PopFollow();

			adaptor.AddChild(root_0, mult100.Tree);
			DebugLocation(156, 9);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:9: ( ( '+' ^| '-' ^) mult )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==28||LA24_1==30))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:10: ( '+' ^| '-' ^) mult
					{
					DebugLocation(156, 10);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:10: ( '+' ^| '-' ^)
					int alt23=2;
					try { DebugEnterSubRule(23);
					try { DebugEnterDecision(23, false);
					int LA23_1 = input.LA(1);

					if ((LA23_1==28))
					{
						alt23 = 1;
					}
					else if ((LA23_1==30))
					{
						alt23 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:11: '+' ^
						{
						DebugLocation(156, 14);
						char_literal101=(IToken)Match(input,28,Follow._28_in_add797); 
						char_literal101_tree = (CommonTree)adaptor.Create(char_literal101);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal101_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:156:18: '-' ^
						{
						DebugLocation(156, 21);
						char_literal102=(IToken)Match(input,30,Follow._30_in_add802); 
						char_literal102_tree = (CommonTree)adaptor.Create(char_literal102);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal102_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(23); }

					DebugLocation(156, 24);
					PushFollow(Follow._mult_in_add806);
					mult103=mult();
					PopFollow();

					adaptor.AddChild(root_0, mult103.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add", 22);
			LeaveRule("add", 22);
			LeaveRule_add();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();
	// $ANTLR start "relation"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:159:1: relation : add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 23);
		TraceIn("relation", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal105 = default(IToken);
		IToken string_literal106 = default(IToken);
		IToken char_literal107 = default(IToken);
		IToken string_literal108 = default(IToken);
		IToken string_literal109 = default(IToken);
		IToken char_literal110 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add104 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add111 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal105_tree = default(CommonTree);
		CommonTree string_literal106_tree = default(CommonTree);
		CommonTree char_literal107_tree = default(CommonTree);
		CommonTree string_literal108_tree = default(CommonTree);
		CommonTree string_literal109_tree = default(CommonTree);
		CommonTree char_literal110_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(159, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:2: ( add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:4: add ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(160, 4);
			PushFollow(Follow._add_in_relation819);
			add104=add();
			PopFollow();

			adaptor.AddChild(root_0, add104.Tree);
			DebugLocation(160, 8);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:8: ( ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==23||(LA26_1>=35 && LA26_1<=36)||(LA26_1>=38 && LA26_1<=40)))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:9: ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^) add
					{
					DebugLocation(160, 9);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:9: ( '==' ^| '!=' ^| '<' ^| '<=' ^| '>=' ^| '>' ^)
					int alt25=6;
					try { DebugEnterSubRule(25);
					try { DebugEnterDecision(25, false);
					switch (input.LA(1))
					{
					case 38:
						{
						alt25 = 1;
						}
						break;
					case 23:
						{
						alt25 = 2;
						}
						break;
					case 35:
						{
						alt25 = 3;
						}
						break;
					case 36:
						{
						alt25 = 4;
						}
						break;
					case 40:
						{
						alt25 = 5;
						}
						break;
					case 39:
						{
						alt25 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:10: '==' ^
						{
						DebugLocation(160, 14);
						string_literal105=(IToken)Match(input,38,Follow._38_in_relation823); 
						string_literal105_tree = (CommonTree)adaptor.Create(string_literal105);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal105_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:18: '!=' ^
						{
						DebugLocation(160, 22);
						string_literal106=(IToken)Match(input,23,Follow._23_in_relation828); 
						string_literal106_tree = (CommonTree)adaptor.Create(string_literal106);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal106_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:26: '<' ^
						{
						DebugLocation(160, 29);
						char_literal107=(IToken)Match(input,35,Follow._35_in_relation833); 
						char_literal107_tree = (CommonTree)adaptor.Create(char_literal107);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal107_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:33: '<=' ^
						{
						DebugLocation(160, 37);
						string_literal108=(IToken)Match(input,36,Follow._36_in_relation838); 
						string_literal108_tree = (CommonTree)adaptor.Create(string_literal108);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal108_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:41: '>=' ^
						{
						DebugLocation(160, 45);
						string_literal109=(IToken)Match(input,40,Follow._40_in_relation843); 
						string_literal109_tree = (CommonTree)adaptor.Create(string_literal109);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal109_tree, root_0);

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:160:49: '>' ^
						{
						DebugLocation(160, 52);
						char_literal110=(IToken)Match(input,39,Follow._39_in_relation848); 
						char_literal110_tree = (CommonTree)adaptor.Create(char_literal110);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal110_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(25); }

					DebugLocation(160, 55);
					PushFollow(Follow._add_in_relation852);
					add111=add();
					PopFollow();

					adaptor.AddChild(root_0, add111.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 23);
			LeaveRule("relation", 23);
			LeaveRule_relation();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// D:\\Eclipse\\aegiscript_live\\aegiscript.g:163:1: expression : relation ( ( '&&' ^| '||' ^) relation )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 24);
		TraceIn("expression", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal113 = default(IToken);
		IToken string_literal114 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relation112 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relation115 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal113_tree = default(CommonTree);
		CommonTree string_literal114_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(163, 1);
		try
		{
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:2: ( relation ( ( '&&' ^| '||' ^) relation )* )
			DebugEnterAlt(1);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:4: relation ( ( '&&' ^| '||' ^) relation )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(164, 4);
			PushFollow(Follow._relation_in_expression866);
			relation112=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation112.Tree);
			DebugLocation(164, 13);
			// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:13: ( ( '&&' ^| '||' ^) relation )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==24||LA28_1==55))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:14: ( '&&' ^| '||' ^) relation
					{
					DebugLocation(164, 14);
					// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:14: ( '&&' ^| '||' ^)
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1==24))
					{
						alt27 = 1;
					}
					else if ((LA27_1==55))
					{
						alt27 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:15: '&&' ^
						{
						DebugLocation(164, 19);
						string_literal113=(IToken)Match(input,24,Follow._24_in_expression870); 
						string_literal113_tree = (CommonTree)adaptor.Create(string_literal113);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal113_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Eclipse\\aegiscript_live\\aegiscript.g:164:23: '||' ^
						{
						DebugLocation(164, 27);
						string_literal114=(IToken)Match(input,55,Follow._55_in_expression875); 
						string_literal114_tree = (CommonTree)adaptor.Create(string_literal114);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal114_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(27); }

					DebugLocation(164, 30);
					PushFollow(Follow._relation_in_expression879);
					relation115=relation();
					PopFollow();

					adaptor.AddChild(root_0, relation115.Tree);

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 24);
			LeaveRule("expression", 24);
			LeaveRule_expression();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _44_in_program94 = new BitSet(new ulong[]{0x45000000008000UL});
		public static readonly BitSet _statement_in_program99 = new BitSet(new ulong[]{0x45000000008000UL});
		public static readonly BitSet _48_in_program104 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_program106 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_constant119 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _type_in_constant121 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _IDENT_in_constant123 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_constant125 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_constant127 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_constant129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _53_in_variable140 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _IDENT_in_variable142 = new BitSet(new ulong[]{0x220000000UL});
		public static readonly BitSet _29_in_variable145 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _IDENT_in_variable147 = new BitSet(new ulong[]{0x220000000UL});
		public static readonly BitSet _33_in_variable151 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _type_in_variable153 = new BitSet(new ulong[]{0x2400000000UL});
		public static readonly BitSet _37_in_variable156 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_variable158 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_variable162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_type174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_ifStatement186 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_ifStatement189 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_ifStatement191 = new BitSet(new ulong[]{0x46C00000008000UL});
		public static readonly BitSet _statement_in_ifStatement193 = new BitSet(new ulong[]{0x46C00000008000UL});
		public static readonly BitSet _elsif_in_ifStatement196 = new BitSet(new ulong[]{0x2C00000000000UL});
		public static readonly BitSet _else_g_in_ifStatement199 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _endif_in_ifStatement202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _47_in_elsif212 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_elsif215 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_elsif217 = new BitSet(new ulong[]{0x44000000008000UL});
		public static readonly BitSet _statement_in_elsif219 = new BitSet(new ulong[]{0x44000000008002UL});
		public static readonly BitSet _46_in_else_g231 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_else_g234 = new BitSet(new ulong[]{0x44000000008000UL});
		public static readonly BitSet _statement_in_else_g236 = new BitSet(new ulong[]{0x44000000008002UL});
		public static readonly BitSet _49_in_endif248 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_endif250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _54_in_whileStatement262 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _whileBody_in_whileStatement265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_whileBody278 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_whileBody280 = new BitSet(new ulong[]{0x45000000008000UL});
		public static readonly BitSet _statement_in_whileBody282 = new BitSet(new ulong[]{0x45000000008000UL});
		public static readonly BitSet _48_in_whileBody285 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_whileBody287 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_whileBody289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_funCallStatement313 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _25_in_funCallStatement315 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_funCallStatement321 = new BitSet(new ulong[]{0x24000000UL});
		public static readonly BitSet _29_in_funCallStatement324 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_funCallStatement330 = new BitSet(new ulong[]{0x24000000UL});
		public static readonly BitSet _26_in_funCallStatement334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyArgsFun_in_funCallStatement356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_emptyArgsFun386 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _25_in_emptyArgsFun388 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_emptyArgsFun390 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentStatement_in_statement412 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funCallStatement_in_statement427 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_statement429 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessorStatement_in_statement434 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_statement436 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignmentStatement447 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_assignmentStatement449 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_assignmentStatement452 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_assignmentStatement454 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignmentStatement461 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_assignmentStatement463 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _accessorStatement_in_assignmentStatement466 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_assignmentStatement468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessor_in_assignmentStatement474 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_assignmentStatement476 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_assignmentStatement479 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_assignmentStatement481 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_accessor498 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_accessor501 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_accessor507 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_accessor509 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _IDENT_in_accessorStatement549 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_accessorStatement552 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _funCallStatement_in_accessorStatement556 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _42_in_array595 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_array600 = new BitSet(new ulong[]{0x80020000000UL});
		public static readonly BitSet _29_in_array604 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_array610 = new BitSet(new ulong[]{0x80020000000UL});
		public static readonly BitSet _43_in_array613 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_array631 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_array632 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_term661 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _25_in_term666 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _expression_in_term668 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_term670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term679 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOL_in_term690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_term695 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_in_term700 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessor_in_term705 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funCallStatement_in_term710 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _52_in_negation722 = new BitSet(new ulong[]{0x10040002119040UL});
		public static readonly BitSet _term_in_negation726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _28_in_unary740 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _30_in_unary745 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _negation_in_unary750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_in_mult761 = new BitSet(new ulong[]{0x8000108000002UL});
		public static readonly BitSet _27_in_mult765 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _32_in_mult770 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _51_in_mult775 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _unary_in_mult779 = new BitSet(new ulong[]{0x8000108000002UL});
		public static readonly BitSet _mult_in_add793 = new BitSet(new ulong[]{0x50000002UL});
		public static readonly BitSet _28_in_add797 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _30_in_add802 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _mult_in_add806 = new BitSet(new ulong[]{0x50000002UL});
		public static readonly BitSet _add_in_relation819 = new BitSet(new ulong[]{0x1D800800002UL});
		public static readonly BitSet _38_in_relation823 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _23_in_relation828 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _35_in_relation833 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _36_in_relation838 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _40_in_relation843 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _39_in_relation848 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _add_in_relation852 = new BitSet(new ulong[]{0x1D800800002UL});
		public static readonly BitSet _relation_in_expression866 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _24_in_expression870 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _55_in_expression875 = new BitSet(new ulong[]{0x10040052119040UL});
		public static readonly BitSet _relation_in_expression879 = new BitSet(new ulong[]{0x80000001000002UL});
	}
	#endregion Follow sets
}

} // namespace 
